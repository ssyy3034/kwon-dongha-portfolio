---
date: 2025-11-04
tags: [CS]
---


# 12.5 세마포어 활용 사례

> [!summary]
> 세마포어는 단순한 **상호 배제(Mutual Exclusion)**뿐 아니라,  
> 스레드 간의 **실행 순서 제어(스케줄링)**에도 활용된다.  
> — _CSAPP p.1363–1364_

---

## 1️⃣ 생산자-소비자 문제 (Producer-Consumer Problem)

> [!abstract] 문제 정의
> **생산자(Producer)** 스레드와 **소비자(Consumer)** 스레드가  
> 크기가 `n`으로 제한된 **유한 버퍼(Bounded Buffer)**를 공유한다.  
> — _CSAPP p.1373_

### 🔑 핵심 제약
1. **상호 배제(Mutual Exclusion)**  
   여러 스레드가 동시에 버퍼에 접근하면 `front`, `rear` 인덱스가 꼬인다.  
   → 임계 구역 보호 필요.

2. **스케줄링(Synchronization)**  
   - 버퍼가 **꽉 차면** 생산자는 **대기**해야 함.  
   - 버퍼가 **비면** 소비자는 **대기**해야 함.  
   — _CSAPP p.1379–1380_

---

### ⚙️ 해결 전략 — 3개의 세마포어

> [!tip]
> 교재의 `SBUF` 패키지는 세 개의 세마포어를 사용한다.  
> — _CSAPP p.1391–1392_

| 이름 | 초기값 | 역할 |
|------|--------|------|
| `mutex` | 1 | 상호 배제 (버퍼 접근 보호) |
| `slots` | n | 빈 슬롯 개수 세기 |
| `items` | 0 | 존재하는 아이템 개수 세기 |

---

### 👨‍🏭 생산자 로직 (`sbuf_insert`)

```c
void sbuf_insert(sbuf_t *sp, int item) {
    P(&sp->slots); // 1. 빈 슬롯이 생길 때까지 대기
    P(&sp->mutex); // 2. 버퍼 잠금 (상호 배제 시작)

    /* 3. 임계 구역: 아이템 삽입 */
    sp->buf[(++sp->rear) % (sp->n)] = item;

    V(&sp->mutex); // 4. 버퍼 잠금 해제
    V(&sp->items); // 5. 소비자에게 "아이템 추가됨" 알림
}
```
> _CSAPP p.1424, 1496–1515_

---

### 👩‍🔧 소비자 로직 (`sbuf_remove`)

```c
int sbuf_remove(sbuf_t *sp) {
    int item;

    P(&sp->items); // 1. 아이템이 생길 때까지 대기
    P(&sp->mutex); // 2. 버퍼 잠금 (상호 배제 시작)

    /* 3. 임계 구역: 아이템 제거 */
    item = sp->buf[(++sp->front) % (sp->n)];

    V(&sp->mutex); // 4. 버퍼 잠금 해제
    V(&sp->slots); // 5. 생산자에게 "빈 슬롯 생김" 알림

    return item;
}
```
> _CSAPP p.1425, 1520–1543_

---

> [!warning] Deadlock 주의
> `P(&sp->slots)`와 `P(&sp->mutex)`의 순서가 중요하다.  
> 만약 `P(mutex)`를 먼저 실행하면, 생산자가 락을 쥔 채로 `slots=0` 상태에서 잠들어버려  
> 소비자가 `P(mutex)`에 접근할 수 없어 **교착 상태(Deadlock)**가 발생한다.

---

## 2️⃣ 독자-저자 문제 (Readers-Writers Problem)

> [!abstract] 문제 정의
> 여러 스레드가 하나의 공유 자원에 접근하는 상황에서  
> **Reader**는 읽기만 하고, **Writer**는 쓰기를 수행한다.  
> — _CSAPP p.1435_

---

### 📜 접근 규칙

1. **쓰기-배타(Write Exclusive)**  
   Writer는 단독 접근이 필요하다.  
   — _CSAPP p.1436_

2. **읽기-공유(Read Shared)**  
   Writer가 없을 때는 여러 Reader가 동시에 접근 가능하다.  
   — _CSAPP p.1436_

---

### ⚙️ 해결 전략 — Reader 우선 (Readers-Preference)

> [!tip]
> 교재의 그림 12.26은 **Reader 우선 접근**을 보장한다.  
> — _CSAPP p.1549–1556_

| 이름 | 초기값 | 역할 |
|------|--------|------|
| `w` | 1 | 공유 객체 접근 제어 (Writer Lock) |
| `mutex` | 1 | `readcnt` 보호용 뮤텍스 |
| `readcnt` | 0 | 현재 Reader 수 카운트 |

---

### ✍️ Writer 로직

```c
void writer(void) {
    while (1) {
        P(&w);     // 1. 독점 접근 획득
        /* 2. 임계 구역: 쓰기 작업 */
        V(&w);     // 3. 독점 접근 해제
    }
}
```
> _CSAPP p.1592–1595_

---

### 👓 Reader 로직

```c
void reader(void) {
    while (1) {
        /* ----- 진입 ----- */
        P(&mutex);        // (A) 카운터 잠금
        readcnt++;
        if (readcnt == 1) // (B) 첫 번째 Reader라면
            P(&w);        // (C) Writer 차단
        V(&mutex);        // (D) 카운터 잠금 해제

        /* ----- 임계 구역 ----- */
        // (E) 읽기 수행 (여러 Reader 동시 가능)

        /* ----- 퇴장 ----- */
        P(&mutex);        // (F) 카운터 잠금
        readcnt--;
        if (readcnt == 0) // (G) 마지막 Reader라면
            V(&w);        // (H) Writer 접근 허용
        V(&mutex);        // (I) 카운터 잠금 해제
    }
}
```
> _CSAPP p.1575–1586_

---

> [!note]
> 이 구조에서는 Reader가 연속해서 들어오면 Writer가 **기아 상태(Starvation)**에 빠질 수 있다.  
> 교재에서는 이후 **Writer 우선(Writers-Preference)** 버전으로 개선하는 예시도 제시한다.
> — _CSAPP p.1600 이후_
