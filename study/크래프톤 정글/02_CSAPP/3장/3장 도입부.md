---
date: 2025-09-18
tags: [CS]
---

기계어보다 고급 언어를 사용하는것이 더 생산적이고, 안정적이지만 기계어 코드를 배워야 하는이유
코드 주요 부분의 성능 극대화를 위해 다양한 형태로 변경을 시도할텐데, 이때 생성된 어셈블리 코드를  컴파일하고 분석하게 된다. 추상화 계층때문에 이해가 필요한 프로그램의 런타임 동작이 감춰지기도 한다.

기계수준 프로그램의 형식과 동작은 인스트럭션 집합 구조에 의해 정의된다.
스칼라 데이터 타입이나 배열,리스트 같은 타입도 연속적인 바이트의 배열로 표시.

3.2 프로그램의 인코딩
프로그램 카운터는 실행할 다음 인스트럭션의 메모리 주소를 가르킴
정수 레지스터 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 가짐.


CSAPP 책에 따르면, 현재 x86-64 머신의 구현에서 가상 주소는 64비트 워드로 표현되지만,

**상위 16비트는 0으로 설정되어야 합니다**1. 이로 인해 실제로 사용할 수 있는 주소 공간은 하위 48비트, 즉 2⁴⁸ 바이트(256테라바이트)로 제한됩니다2.

---

### ## 왜 64비트 전체가 아닌 48비트만 사용하나요? 💡

이러한 제한을 두는 데에는 몇 가지 현실적인 이유가 있습니다.

- **현재 기술의 한계와 비용**: 현재 기술로는 64비트가 표현할 수 있는 전체 메모리(16엑사바이트)를 물리적으로 만드는 것이 거의 불가능하며 매우 비효율적입니다. 48비트(256TB)만으로도 현재와 가까운 미래에 필요한 메모리 공간을 충분히 감당할 수 있습니다.
    
- **하드웨어의 효율성**: 주소 전체를 사용하지 않으면 주소를 변환하는 하드웨어(MMU, 메모리 관리 장치)를 더 간단하고 빠르게 만들 수 있습니다. 예를 들어, 9장에서 설명하는 페이지 테이블의 단계 수를 줄여 메모리 접근 속도를 높일 수 있습니다.
    
- **미래를 위한 확장성**: 지금은 48비트만 사용하지만, 아키텍처 자체는 64비트를 지원하도록 설계되었습니다. 따라서 나중에 더 큰 메모리 공간이 필요해지면, 하위 호환성을 유지하면서 49비트, 50비트 등으로 점차 확장해 나갈 수 있습니다.
    

---

###  정확한 규칙: 정규 주소 형식 (Canonical Address Form)

사실 "상위 16비트가 0이어야 한다"는 것은 사용자 프로그램 주소에 해당하는 절반의 이야기입니다. 더 정확한 x86-64의 규칙은 **정규 주소 형식(canonical form)**을 따라야 한다는 것입니다.

- 정규 주소 형식에서 64비트 주소의 **하위 48비트(비트 0~47)만 실제 주소로 사용**됩니다.
    
- **상위 16비트(비트 48~63)는 모두 47번 비트의 값과 동일해야 합니다.** 즉, **부호 확장(sign extension)**과 비슷한 규칙이 적용됩니다.
    

이 규칙에 따라 유효한 주소는 두 개의 큰 범위로 나뉩니다.

- **사용자 공간**: 47번 비트가 `0`이면, 상위 16비트는 모두 `0`이어야 합니다. `0x0000000000000000` ~ `0x00007FFFFFFFFFFF` 범위의 주소가 여기에 해당합니다.
    
- **커널 공간**: 47번 비트가 `1`이면, 상위 16비트는 모두 `1`이어야 합니다. `0xFFFF800000000000` ~ `0xFFFFFFFFFFFFFFFF` 범위의 주소가 여기에 해당합니다.
    

우리가 일반적으로 작성하고 실행하는 사용자 프로그램은 모두 사용자 공간에서 실행되므로, 이 프로그램들이 사용하는 가상 주소의 상위 16비트는 모두 0이 되는 것입니다. CSAPP 책에서 "상위 16비트는 0으로 설정되어야 한다"고 설명한 것은 바로 이 때문입니다.

.c코드를 .o코드로 생성하면 파일 크기가 늘어난 것을 볼 수 있는데, 그 이유는 운영체제와 상호작용하기 위한 코드, 그리고 프로그램 시작/종료를 위한 코드들도 포함되기 때문이다.

근본적으로 16비트를 사용하다가 32비트로 확장해서 16비트 데이터 타입을 인텔은 워드 라고 말함. 32비트는 더블 워드, 64비트는 쿼드 워드다.
접미어를 가지는데, b,w,l,q 가 있다.
순서대로 바이트,워드,더블워드,쿼드워드다. 이 단위로 정수 레지스터에 접근할수 있다.

- **실행 파일 → 메모리 적재 → PC(프로그램 카운터)**  
    OS 로더가 코드(.text)를 메모리에 올리고 시작 주소를 PC에 넣어줌. CPU는 **PC가 가리키는 바이트들만 ‘명령어’로 간주**해서 가져와 실행해.
    
- **무엇이 명령어인가? → ISA 규칙 + 위치(PC)**  
    CPU가 파일 전체를 스캔해 “이건 코드, 이건 데이터”라고 구분하지 않아. **PC가 가리키는 곳**을 명령 스트림으로 보고, **ISA가 정한 인코딩 규칙**대로 해석함.
    
- **인코딩 규칙(ISA)이 모든 걸 결정**
    
    - **고정 길이**(예: RISC-V 기본 32비트): 항상 같은 폭. 필드 위치가 고정(opcode, rd, rs, imm 등). PC는 +4(또는 +2)씩 전진.
        
    - **가변 길이**(예: x86): 프리픽스 → opcode → ModR/M → SIB → 변위 → 즉시값 순으로 **앞에서부터 읽으며 길이와 형식**을 결정. 명령 경계 찾는 전처리/디코더가 복잡.
        
- **어셈블러의 역할**  
    사람이 쓰는 **어셈블리 텍스트**를 **기계어 바이트열(opcode+피연산자 비트)** 로 인코딩. 즉, “명령어 vs 피연산자(레지스터/즉시값/메모리)”를 **어셈블 시점에 규칙에 맞춰 분해·배치**해 줌. CPU는 결과 바이트만 읽음.
    
- **파이프라인 흐름(요지)**  
    **Fetch(PC) → Decode(비트 필드 분해/마이크로코드 가능) → Execute → Memory → Writeback → PC 업데이트(분기 시 점프)**. 분기 예측, I-캐시 등은 성능 최적화용.
    
- **기타 헷갈리기 쉬운 포인트**
    
    - **엔디안**: 바이트 나열 규칙일 뿐, **명령어 경계/의미는 ISA 규칙**이 책임.
        
    - **정렬(Alignment)**: 몇 ISA는 2/4바이트 경계 강제, 위반 시 예외.
        
    - **코드/데이터 오인**: 구분 못 함. 그래서 **NX/W^X** 같은 보호가 중요.
        
    - **즉시값/분기 오프셋**: 여러 비트 조각을 이어 붙이고 **부호 확장** 규칙 적용.
        

요약하면: **“PC가 가리키는 바이트”를 CPU가 **ISA 인코딩 규칙**대로 디코드해서 실행한다.** 고정 길이는 단순, 가변 길이는 디코더가 단계별로 길이와 의미를 정한다.