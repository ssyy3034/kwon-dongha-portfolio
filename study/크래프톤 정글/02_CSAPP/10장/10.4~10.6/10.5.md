---
date: 2025-10-30
---

# [[RIO 패키지]] 의 두 가지 기능

RIO 패키지는 두 가지 종류의 함수를 제공하여 다양한 상황에 대처할 수 있도록 합니다.

### 1. 버퍼 없는 입출력 (Unbuffered I/O)

- **함수:** [[rio_readn, rio_writen]]
    
- **역할:** 응용 프로그램 수준의 버퍼링 없이, 메모리와 파일 사이에서 데이터를 직접 전송합니다.
    
- **주요 용도:** 네트워크를 통해 바이너리 데이터를 주고받는 것처럼, 데이터가 가공 없이 그대로 전달되어야 할 때 특히 유용합니다. 이 함수들은 short count가 발생하면, 요청된 모든 바이트가 전송될 때까지 내부적으로 `read`나 `write`를 반복 호출하여 안정성을 보장합니다.
    

### 2. 버퍼를 사용하는 입력 (Buffered Input)

- **함수:** [[rio_readlineb, rio_readnb]]
    
- **역할:** 응용 프로그램 수준에 마련된 버퍼(내부 창고)를 사용해 입력 성능을 높입니다.
    
- **동작 방식:**
    
    1. `read`를 한 번 호출해서 가능한 많은 데이터를 내부 버퍼로 미리 가져옵니다.
        
    2. 이후 프로그램이 데이터를 요청하면, 커널에 다시 요청하는 대신 이 빠른 내부 버퍼에서 데이터를 꺼내줍니다.
        
    3. 버퍼가 비워지면 그때 다시 `read`를 호출하여 버퍼를 채웁니다.
        
- **주요 용도:** 텍스트 파일을 한 줄씩 효율적으로 읽거나(`rio_readlineb`), 버퍼를 통해 바이너리 데이터를 읽을 때(`rio_readnb`) 사용됩니다.
### ## 버퍼를 사용하는 출력: 왜 RIO에는 없을까?

RIO 패키지는 버퍼를 사용하는 입력 함수는 제공하지만, **의도적으로 버퍼를 사용하는 출력 함수는 제공하지 않습니다.** 이는 RIO의 설계 목적이 **안정적인 데이터 전송**에 더 큰 중점을 두기 때문입니다.

- **출력의 핵심 과제:** 출력 작업에서 가장 중요한 것은 [[Short Count]]가 발생하더라도 **요청한 모든 데이터가 빠짐없이 전송되는 것을 보장**하는 것입니다. [[rio_readn, rio_writen]] 의 `rio_writen` 함수가 이 역할을 완벽하게 수행합니다.
    
- **안정성 우선:** `rio_writen`은 short count가 발생하면 알아서 `write`를 재시도하여 요청한 데이터가 커널 버퍼로 모두 전달되는 것을 보장합니다. 네트워크 프로그래밍에서는 이것만으로도 충분히 안정적이고 편리합니다.
    
- **포맷팅 출력 해결책:** 만약 `printf`처럼 형식을 갖춘 문자열을 출력하고 싶다면, `sprintf` 함수를 사용해 메모리 버퍼에 문자열을 미리 만든 뒤, 완성된 문자열을 `rio_writen`으로 한 번에 보내는 방식이 권장됩니다. 이 방법은 RIO의 안정성을 유지하면서 버퍼 출력과 유사한 효과를 냅니다.
[[버퍼없는 입출력으로 네트워크 통신을 사용하는 이유]]