---
date: 2025-10-08
tags: [CS]
---


> **한 줄 요약**: C는 컴파일·링크·실행의 관점과, "선언 vs 정의", "링키지/저장수명/스코프"를 잡으면 70% 끝이다. 나머지는 **헤더 배치**, **메모리 관리**, **배열·포인터 차이**, **전처리기**, **가변 인자**, **비트 연산** 실전 팁으로 채운다.

---

## 1) 선언(Declaration) vs 정의(Definition)

- **선언**: "이런 심볼이 **있다**"고 컴파일러에 알림. **타입/링키지** 정보만 제공.  
    예) `extern int a;`, `int func(int);`
    
- **정의**: 메모리/코드의 **실체**를 만든다.  
    예) `int a = 10;`, 함수 본문 `int func(int x){...}`
    
- **테크 디테일**
    
    - **하나의 정의 원칙**(C에서는 번역 단위별 다르게 적용): 같은 프로그램에 **전역 변수의 다중 정의**는 링크 에러.
        
    - **tentative definition**: 파일 스코프에서 `int x;`만 쓰면 일단 선언처럼 보이지만, **해당 번역 단위에서 정의가 없으면** `int x = 0;`으로 **정의 취급**.
        

**한 줄 비유**: 선언=명함, 정의=사람 본인.

---

## 2) 헤더(.h) vs 소스(.c)

- **.h(헤더)**: 외부에 공개할 **선언** 모음(인터페이스). 구조체 태그, 함수 프로토타입, 상수, 매크로 등.
    
- **.c(소스)**: **정의**와 구현. 내부 헬퍼는 여기 숨긴다.
    

```c
// math.h
#ifndef MATH_H
#define MATH_H
int add(int a, int b);
#endif

// math.c
#include "math.h"
int add(int a, int b) { return a + b; }

// main.c
#include <stdio.h>
#include "math.h"
int main(void) { printf("%d\n", add(2,3)); }
```

**헤더 가드**: `#ifndef/#define/#endif` 또는 `#pragma once`로 **중복 포함** 방지.

---

## 3) 전방선언(Forward Declaration)

- **아직 정의를 안 보여줬지만, 쓸 일**이 있을 때 미리 알려두는 선언.
    
- 함수는 프로토타입만 있으면 된다: `int foo(int);`
    
- **불완전 타입(incomplete type)** 활용: 포인터는 크기가 고정이라 **정의 없이**도 쓸 수 있다.
    

```c
struct Node;           // 구조체 전방선언(불완전 타입)
void push(struct Node** head, int x); // 포인터로만 사용 가능

struct Node {          // 여기서야 비로소 완전 타입
  int data;
  struct Node* next;
};
```

> 주의: **enum은 전방선언 불가**(정의가 필요). `union`/`struct`는 가능.

---

## 4) static / extern — 링키지와 저장수명

|키워드|핵심 의미|링키지|저장수명|스코프|
|---|---|---|---|---|
|`extern` 전역|**외부 링키지**: 다른 번역 단위에서 참조 가능|external|static|파일 스코프|
|`static` 전역|**내부 링키지**: 파일 내부에서만 보임|internal|static|파일 스코프|
|`static` 지역|블록 스코프 **지만** 수명은 프로그램 전체|없음|static|블록|

```c
// a.c
int g = 10;      // 외부 링키지 정의
static int s = 5; // 내부 링키지 정의(파일 한정)

// b.c
extern int g;    // 선언(정의는 a.c에 있음) → OK
// extern int s; // s는 내부 링키지라 다른 파일에서 불가
```

**보너스**

- 함수에 `static` 붙이면 **그 파일에서만 호출 가능**(내부 링키지 함수).
    
- 지역변수 `static`은 한 번만 초기화되고 함수 종료 후에도 **값 보존**.
    

---

## 5) enum (열거형)

- **이름 붙은 정수 상수** 집합. 기본 타입은 `int` 범위.
    

```c
enum Color { RED = 1, GREEN, BLUE = 10, MAGENTA };
// GREEN==2, MAGENTA==11
```

**팁**

- 플래그에는 보통 `1<<n` 형태의 **비트 플래그**가 더 낫다(상호 배타 값이면 enum 사용).
    
- 열거형 **크기/서명**은 구현 정의. 외부 인터페이스에는 **고정폭 정수**(`int32_t`)를 선호.
    

---

## 6) union (공용체)

- **하나의 메모리를 여러 타입으로 해석**. 동시에 하나만 유효.
    
- 크기 = **가장 큰 멤버 크기**(정렬 때문에 패딩 포함).
    

```c
union Data { int i; float f; unsigned u; };
```

|비교|`struct`|`union`|
|---|---|---|
|메모리 배치|멤버 각각 공간|모든 멤버 **공유**|
|동시 저장|가능|불가능(논리적으로 하나만)|
|크기|합(패딩 포함)|최대 멤버 크기(패딩 포함)|

**주의(타입 퍼닝)**

- 다른 멤버로 읽으면 **엄밀히는 정의되지 않을 수 있음**(strict aliasing). 가장 안전한 건 `memcpy`.
    

---

## 7) 빌드 파이프라인: 전처리 → 컴파일 → 어셈블 → 링크 → 실행

1. **전처리** `gcc -E` : 매크로 치환, `#include` 전개, 조건부 컴파일.
    
2. **컴파일** `gcc -S` : C → 어셈블리(.s).
    
3. **어셈블** `gcc -c` : 어셈블리 → **목적파일**(.o).
    
4. **링크** `gcc a.o b.o -o app` : 심볼 해석, 라이브러리 결합 → 실행 파일.
    

**추가 포인트**

- 정적 라이브러리 `.a`, 공유 라이브러리 `.so`(윈도우 `.lib`/`.dll`).
    
- **링크 순서** 중요(특히 정적 라이브러리): 의존 대상은 **뒤에**.
    
- 에러 패턴: _undefined reference_(선언만 있고 정의 없음) / _multiple definition_(중복 정의).
    

---

## 8) 동적 메모리: malloc / calloc / realloc / free

- 헤더: `#include <stdlib.h>`
    
- `malloc(n)` : n바이트 **할당(미초기화)**
    
- `calloc(k, sz)` : k×sz 바이트 **0으로 초기화**
    
- `realloc(p, n)` : 크기 조정(이동될 수 있음)
    
- `free(p)` : 해제 → **포인터를 즉시 NULL 세팅** 습관
    

```c
int *p = malloc(sizeof *p * 5);
if (!p) return -1;   // 실패 체크
p[0] = 10;
int *q = realloc(p, 10 * sizeof *p);
if (!q) { free(p); return -1; }
p = q;
free(p); p = NULL;
```

**주의**

- **double free / use-after-free** 금지.
    
- 반환값 NULL 체크는 **필수**.
    
- 구조체 트리/리스트는 **소유권**(누가 free?)을 문서화.
    

---

## 9) 배열과 포인터 — 닮은 듯 다른 둘

- 배열은 **연속 메모리**. 식에서 대부분 **첫 원소 주소로 decay**.
    
- 하지만 **동일하지 않다**:
    
    - `sizeof(arr)`는 전체 크기, `sizeof(ptr)`은 포인터 크기.
        
    - 함수 인자로 `int arr[]`는 **사실상** `int *arr`.
        
    - 배열은 **대입 불가**(다른 배열에 통째로 = 못 함). `memcpy`/루프로 복사.
        

```c
int a[3] = {10,20,30};
int *p = a;           // decay
*(a+1) == a[1];       // true
sizeof(a) == 12;      // 3 * sizeof(int) (32비트 int 가정)
sizeof(p) == 8;       // 64비트 포인터 가정
```

**다차원**

- `int m[3][4]`는 (연속) 배열의 배열. 함수 인자로 보낼 때는 **내부 차원**이 필요: `void f(int m[][4]);`
    
- 포인터의 포인터(`int **`)와는 **다른 레이아웃**.
    

---

## 10) Call by Value / Reference

- C는 **항상 Call by Value**. 참조처럼 보이는 건 사실 **포인터 전달**.
    

|구분|설명|특징|
|---|---|---|
|값 호출|값 복사|원본 영향 X|
|참조 흉내|주소 전달(포인터)|원본 직접 수정 가능|

```c
void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; }
```

**const의 두 얼굴**

- `const int *p` : **포인터가 가리키는 값** 불변(포인터는 움직여도 됨)
    
- `int * const p` : 포인터 **자체**가 불변(가리키는 값은 수정 가능)
    
- `const int * const p` : 둘 다 불변
    

---

## 11) 가변 인자(Variable Arguments)

- 헤더: `#include <stdarg.h>`
    
- 규칙: **반드시** 고정 인자 하나 이상이 필요(경계 표시).
    
- **기본 인자 승격** 발생: `float`는 `double`로, `char`/`short`는 `int`로.
    

```c
void sum(int count, ...) {
    va_list args; va_start(args, count);
    long total = 0;
    for (int i = 0; i < count; i++) total += va_arg(args, int);
    va_end(args);
    printf("sum = %ld\n", total);
}
```

**주의**

- 호출자/피호출자 간 **타입 합의**가 깨지면 **UB(Undefined Behavior)**.
    
- `printf`는 포맷 문자열로 타입을 **명시**해 이 위험을 줄인다.
    

---

## 12) 전처리기(Preprocessor)

> 바로잡음: `typedef`는 **전처리 지시어가 아니다**. `typedef`는 **언어 키워드**. 전처리는 `#`로 시작하는 애들이다.

|지시어|역할|예시|
|---|---|---|
|`#define`|매크로 정의/치환|`#define PI 3.14159`|
|`#undef`|매크로 해제|`#undef PI`|
|`#include`|헤더 포함|`#include <stdio.h>`|
|`#if/#ifdef/#ifndef/#elif/#endif`|조건부 컴파일|디버그 빌드 분기|
|`#error`|빌드 중단 메시지|`#error "wrong platform"`|
|`#pragma`|구현 확장 지시|`#pragma once`(관용)|

**매크로 팁**

```c
#define SQR(x) ((x)*(x))        // 괄호 필수
#define STR2(x) #x               // 문자열화
#define CAT(a,b) a##b            // 토큰 결합
```

---

## 13) list iteration (Pintos 스타일)

- 커널 스타일의 **내장 리스트 노드**를 구조체에 박아 쓰는 패턴.
    

```c
struct my_struct {
    int val;
    struct list_elem elem; // 내장 노드
};

for (e = list_begin(&mylist);
     e != list_end(&mylist);
     e = list_next(e)) {
    struct my_struct *s = list_entry(e, struct my_struct, elem);
}
```

**삭제가 섞일 때는 _safe 순회**

```c
for (e = list_begin(&mylist); e != list_end(&mylist); ) {
    struct list_elem *next = list_next(e);
    struct my_struct *s = list_entry(e, struct my_struct, elem);
    if (need_delete(s)) list_remove(e);
    e = next;
}
```

---

## 14) 비트 연산자 — 플래그/상태 제어의 기본기

|연산자|의미|예시|결과|
|---|---|---|---|
|`&`|AND|`6 & 3`|`2`|
|`|`|OR|`6|
|`^`|XOR|`6 ^ 3`|`5`|
|`~`|NOT|`~6`|비트 반전|
|`<<`|왼쪽 시프트|`3 << 1`|`6`|
|`>>`|오른쪽 시프트|`6 >> 1`|`3`|

**플래그 예시**

```c
#define READ   (1u << 0) // 0001
#define WRITE  (1u << 1) // 0010

unsigned mode = READ | WRITE;      // 설정
if (mode & READ)   puts("읽기 가능"); // 검사
mode &= ~WRITE;                     // 해제
```

**주의 디테일**

- **우선순위**: `&` < `^` < `|` 순서. 괄호로 의도를 드러내라.
    
- **부호 있는 오른쪽 시프트**는 구현 정의(산술/논리). 부호 비트 보존에 의존하지 말 것.
    
- **마스크**는 부호 없는 타입을 쓰자(`uint32_t`).
    

---

## 15) 보너스: 인라인·어설션·컴파일 옵션

- `inline` 함수: 호출 오버헤드 감소(최적화 힌트 수준).
    
- `assert()`(`assert.h`): 디버그 조건 체크, NDEBUG로 비활성화.
    
- 유용한 옵션: `-Wall -Wextra -Werror -std=c11 -O2 -g -fsanitize=address,undefined`.
    

---

## ✅ 요약 체크리스트

- **선언 vs 정의**: 약속 vs 실체, 파일 스코프의 **tentative definition** 기억.
    
- **링키지/수명/스코프**: `static/extern` 조합을 확실히.
    
- **헤더 가드**: 중복 포함 방지, 구현은 `.c`에 숨기기.
    
- **동적 메모리**: 소유권/해제 규칙, `NULL` 처리, `realloc` 예외 처리.
    
- **배열/포인터**: decay, `sizeof` 차이, 다차원 인자 규칙.
    
- **가변 인자**: 타입 합의·승격 규칙, `printf` 패턴.
    
- **전처리기**: 매크로 괄호, 조건부 컴파일, `#error`로 실패를 조기 표면화.
    
- **비트 연산**: 마스크·플래그 패턴, 부호 없는 타입 사용.
    

> 모호한 개념 보이면 예제 코드를 **직접 컴파일**해서 확인하자. 빠르게 실험하는 습관이 가장 큰 지름길이다.