---
date: 2025-09-26
tags: [CS]
---

# Bomb Lab – Phase 2 정리

## Prologue

Phase 2는 “단순한 반복문도 어셈블리로 내려가면 이렇게 보이는구나”를 체감하게 해주는 단계였다.  
단순히 코드를 풀었다기보다, **연속된 관계를 검증하는 구조**를 직접 뜯어본 경험이 남았다.

---

## 핵심: 반복문과 순차적 검사

- 이 단계는 6개의 숫자를 입력받는다.
    
- 첫 번째 숫자가 기준이고, 나머지는 모두 **순차적으로 조건을 만족해야** 한다.
    
- 비유하자면 도미노처럼 이어진다. 하나라도 어긋나면 폭탄이 터진다.
    

C 코드로 단순화하면 다음과 같다:

```c
int numbers[6];
read_six_numbers(numbers);

if (numbers[0] != 1) bomb();

for (int i = 1; i < 6; i++) {
    if (numbers[i] != numbers[i-1] * 2) {
        bomb();
    }
}
```

---

## 공략 단계

### 1. 입력값 개수 확인

- `<read_six_numbers>` 호출 → 6개 정수 입력이 필요하다는 걸 알 수 있다.
    

### 2. 반복문 구조 분석

- 카운터 레지스터: 반복 횟수 관리
    
- 포인터 레지스터: 배열 주소 이동
    
- 종료 조건: 6번 채워질 때까지 반복
    

### 3. 핵심 조건 파악

- 반복문 내부에서 `cmpl` → `jne explode_bomb` 패턴 확인
    
- 이는 곧 “조건 불일치 시 폭탄”이라는 의미
    
- 따라서 이전 숫자를 기반으로 규칙을 찾아내야 한다.
    

**실전 팁**  
`jne` 직전에 브레이크포인트를 걸고 `info registers`로 레지스터 상태를 확인하면,  
비교되는 값(프로그램이 기대하는 값 vs 내가 입력한 값)을 한눈에 알 수 있다.

### 4. 첫 번째 숫자 찾기

- 반복문 전에 첫 번째 숫자 검증 코드가 있다.
    
- 보통 `1` 또는 `0`으로 시작하는 경우가 많다.
    
- 그 값이 기준이 되고, 이후 숫자는 일정한 규칙(예: 이전 값의 2배)을 따라가면 된다.
    

---

## 배운 점

- 반복문이 어셈블리로 구현되는 흐름을 직접 확인하면서, 단순한 `for` 문도 결국은 **비교와 점프**의 연속이라는 사실을 체감했다.
---

## 회고

Phase 2는 본격적인 난이도 상승 직전의 “워밍업” 같았다.  
하지만 동시에, 단순한 반복조차도 어셈블리에서 보면 얼마나 명확하고 단호한 구조로 바뀌는지 깨달았다.  
이 경험 덕분에 이후 단계에서도 “규칙을 코드에서 직접 증명해야 한다”는 관점을 잡을 수 있었다.
