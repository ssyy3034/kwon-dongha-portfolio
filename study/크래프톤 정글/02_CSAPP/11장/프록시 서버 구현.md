---
date: 2025-11-02
tags: [CS]
---


### **1단계: 기본 프록시 구현 (순차 처리) - [충분히 가능]**

이 단계는 `tiny` 서버 코드와 교재의 에코 클라이언트/서버 예제를 조합하고 응용하면 인터넷 도움 없이 충분히 구현할 수 있습니다.

#### **활용할 수 있는 지식 (책 + `tiny` 코드):** 

1. **서버의 기본 구조 (`tiny.c`의 `main` 함수)**:
    
    - `main` 함수에서 포트 번호를 인자로 받는 법.
         
    - `open_listenfd`로 리슨 소켓을 여는 법.
        
    - `while(1)` 루프 안에서 `accept`로 클라이언트 연결을 기다리는 구조.
        
    - 이 구조는 프록시 서버에서도 거의 그대로 사용됩니다.
        
2. **클라이언트 기능 구현 (`open_clientfd` 함수 및 에코 클라이언트)**:
    
    - **가장 중요한 부분입니다.** 프록시는 클라이언트의 요청을 받는 **'서버'**인 동시에, 최종 목적지 서버에 접속하는 **'클라이언트'**의 역할도 수행합니다.
        
    - 교재의 `open_clientfd` 함수와 에코 클라이언트 예제 코드는 프록시가 최종 서버에 어떻게 접속(`connect`)하고 데이터를 보내는지(`Rio_writen`)에 대한 완벽한 가이드를 제공합니다.
        
3. **HTTP 요청 파싱 (`tiny.c`의 `doit`, `parse_uri` 함수)**:
    
    - `tiny`는 `GET /home.html HTTP/1.0`과 같은 요청 라인을 `sscanf`로 파싱합니다. 프록시도 이와 유사하게 요청 라인을 파싱해야 합니다.
        
    - **도전 과제**: `tiny`와 달리 프록시는 `GET http://www.google.com/index.html HTTP/1.0`과 같은 전체 URL을 받습니다. 여기서 `http://`, 호스트 이름, 경로, 포트 번호를 분리해내는 더 정교한 문자열 처리(`strstr`, `strchr`, `sscanf` 활용)가 필요합니다. 이 부분은 C언어 문자열 함수에 대한 깊은 이해가 필요합니다.
        

**결론**: 1단계는 `tiny` 서버 코드(서버 역할)와 에코 클라이언트 코드(클라이언트 역할)를 **하나의 프로그램 안에서 합치는 과정**으로 볼 수 있습니다. 책에 나온 함수들과 C언어 기본기만으로 충분히 해결 가능합니다.

---

### **2단계: 동시성 프록시 구현 (병렬 처리) - [어렵지만 가능]**

이 단계부터 난이도가 급격히 올라갑니다. 하지만 CSAPP 교재는 이 주제를 매우 비중 있게 다루므로, 책을 깊이 파고든다면 가능합니다.

#### **활용할 수 있는 지식 (책 12장):**

1. **동시성 모델 선택**: CSAPP 12장 '동시성 프로그래밍(Concurrent Programming)'에 모든 핵심 개념이 들어있습니다.
    
    - **멀티프로세싱 (`fork`)**: `tiny` 서버의 `serve_dynamic`에서 이미 `fork`를 사용하는 예시를 보았습니다. 이를 응용하여 `accept` 후 자식 프로세스를 생성하여 각 클라이언트를 처리하게 할 수 있습니다.
        
    - **멀티스레딩 (`pthread`)**: 교재 12장에서 스레드 생성(`pthread_create`), 스레드 함수 작성, 스레드 종료(`pthread_detach`)에 대해 상세히 설명합니다. 프록시 랩에서는 일반적으로 멀티스레딩 방식이 더 선호됩니다.
        
2. **구현의 핵심**:
    
    - `main` 함수의 `while` 루프는 `accept`만 담당하고, 실제 처리 로직(1단계에서 구현한 모든 것)을 별도의 스레드 함수로 옮겨야 합니다.
        

#### **어려움이 예상되는 부분 (인터넷 검색 유혹이 강해지는 지점):**

- **스레드에 인자 전달**: `pthread_create`는 스레드 함수에 단 하나의 `void *` 인자만 전달할 수 있습니다. `accept`로 받은 `connfd`(정수)를 어떻게 스레드에 안전하게 전달할 것인가?
    
    - **해결 힌트 (책 기반)**: `malloc`으로 메모리를 할당해 `connfd`를 저장하고 그 포인터를 넘겨주는 것이 일반적입니다. 스레드 함수는 이 포인터를 받아 값을 사용한 뒤 `free` 해주어야 합니다. 이 과정에서 발생하는 미묘한 버그를 잡는 것이 어려울 수 있습니다.
        
- **경쟁 상태(Race Condition)**: 지금은 괜찮지만, 3단계 캐싱을 구현하면 여러 스레드가 동시에 공유 데이터(캐시)에 접근하면서 문제가 발생합니다.
    

**결론**: 2단계는 **CSAPP 12장을 완벽히 이해하고 응용하는 시험대**입니다. 책에 나온 예제 코드를 깊이 분석하고 디버깅한다면 인터넷 없이도 구현할 수 있습니다.

---

### **3단계: 캐싱 프록시 구현 - [매우 어려움]**

이 단계는 **책에 명시적인 '정답' 코드가 없기 때문에** 가장 어렵습니다. 교재는 필요한 도구(자료구조, 동기화 기법)를 주지만, 그것들을 조합하여 캐시 시스템을 '설계'하는 것은 온전히 여러분의 몫입니다.

#### **활용할 수 있는 지식 (책의 여러 부분):**

1. **자료구조 설계**:
    
    - 캐시된 웹 객체를 어떻게 저장할 것인가? 가장 간단하게는 **구조체 배열**로 시작할 수 있습니다.
        
    - 더 나아가 **연결 리스트(Linked List)**를 사용하면 LRU(Least Recently Used) 같은 교체 정책을 구현하기 용이합니다. C언어로 연결 리스트를 구현하는 것은 자료구조 지식이 필요합니다.
        
2. **캐시 교체 정책 (Eviction Policy)**:
    
    - 캐시가 꽉 찼을 때 어떤 데이터를 삭제할 것인가? **LRU**가 일반적입니다. 이를 구현하려면 각 캐시 블록에 마지막 접근 시간을 기록하거나, 접근할 때마다 연결 리스트의 순서를 변경하는 로직을 직접 설계해야 합니다.
        
3. **동기화 (Synchronization)**:
    
    - **가장 어려운 부분입니다.** 여러 스레드가 동시에 캐시를 읽고 쓰는 상황에서 데이터가 깨지는 것을 막기 위해 **뮤텍스(Mutex)나 세마포어(Semaphore)를 사용한 동기화**가 필수적입니다.
        
    - CSAPP 12장에서 `pthread_mutex_lock`, `pthread_mutex_unlock` 같은 함수를 설명합니다. "어디를 lock하고 어디서 unlock할 것인가?"를 정확히 설계하는 것이 핵심이며, 잘못하면 데드락(Deadlock)에 빠질 수 있습니다.
        

**결론**: 3단계는 교재에 흩어져 있는 시스템 프로그래밍, 자료구조, 동시성 개념을 총동원하여 **새로운 시스템을 설계하는 과정**에 가깝습니다. 인터넷 도움 없이 해낸다면 엄청난 성취감을 느낄 수 있겠지만, 가장 시간이 오래 걸리고 막막하게 느껴질 수 있는 부분입니다.

**최종 조언**: **1단계 → 2단계 → 3단계 순서**를 반드시 지키고, 각 단계가 `driver.sh`의 해당 테스트를 통과할 때까지 다음으로 넘어가지 마세요. 막힐 때는 책의 관련 챕터를 다시 정독하고, `tiny`나 에코 서버 같은 예제 코드에서 힌트를 얻는 것이 인터넷 검색보다 훨씬 더 깊이 있는 학습으로 이어질 것입니다.

[[구현팁]]