---
date: 2025-09-19
category: 알고리즘
week: 38
tags: [Algorithm, CLRS, 그래프이론, 알고리즘, 위상정렬, 재귀]
---

# 위상 정렬 (Topological Sort) 정리

## 1) 정의 한 줄 요약

**위상 정렬(topological sort)** 은 **방향 비순환 그래프(DAG)** 의 모든 정점을,  
모든 간선 $(u \to v)$에 대해 **$u$가 $v$보다 먼저 나오도록** 일렬로 나열한 결과다.

즉, “**선수 과목이 먼저, 후수 과목이 나중**”이라는 **의존성 순서**를 만족하는 선형 나열을 구하는 과정이다.

---

## 2) 왜 꼭 DAG여야 할까?

- **사이클이 있는 경우**:  
    $u \to v \to \cdots \to u$처럼 돌아오는 구조가 있으면  
    $u$와 $v$가 서로의 선행 조건이 되어 순서를 정할 수 없다.
    
- 따라서 **위상 정렬이 가능 ⇔ 그래프가 DAG**라는 성질이 성립한다.  
    → 실제로 **위상 정렬 알고리즘**은 DAG 여부 판정 기능까지 포함한다.
    

---

## 3) 대표 알고리즘 두 가지

### A) DFS 기반 방법 (완료 시간 역순)

1. 그래프에 DFS를 돌리며 각 정점의 **발견 시간 $d[u]$**, **완료 시간 $f[u]$**를 기록한다.
    
2. 모든 정점 탐색이 끝나면, **완료 시간이 큰 정점부터 나열**하면 위상 순서가 된다.
    

- **직관**: DAG에서 간선 $(u \to v)$가 있으면, $u$가 완료되려면 $v$를 반드시 먼저 처리해야 한다.  
    따라서 항상 $f[v] < f[u]$.  
    즉, **완료 시간 내림차순**은 간선 방향을 자동으로 존중한다.
    
- **복잡도**: 인접 리스트 기준 **$O(V+E)$**
    

---

### B) Kahn 알고리즘 (진입 차수 0부터 꺼내기)

1. 모든 정점의 **진입 차수(in-degree)** 를 계산한다.
    
2. 진입 차수가 0인 정점들을 큐에 넣는다.
    
3. 큐에서 정점을 꺼내 결과에 추가하고, 그 정점에서 나가는 간선을 제거한다.
    
    - 이때 도착 정점의 진입 차수를 1 줄인다.
        
    - 새로 0이 되는 정점을 큐에 넣는다.
        
4. 큐가 빌 때까지 반복한다.
    

- **사이클 검출**: 모든 정점을 다 꺼내지 못했다면 → 아직 진입 차수 > 0인 정점이 남았다 → 사이클 존재.
    
- **복잡도**: 인접 리스트 기준 **$O(V+E)$**
    

---

## 4) 올바름(정확성) 감각

- **DFS 방법**
    
    - 간선은 항상 “완료 시간이 더 큰 쪽 → 더 작은 쪽”으로 향한다.
        
    - 따라서 **완료 시간 내림차순**이 곧 위상 순서다.
        
- **Kahn 방법**
    
    - “앞에 올 수 있는 건 항상 **진입 차수 0**뿐”
        
    - 지금 당장 선행 조건이 없는 정점만 뽑기 때문에, 언제 뽑든 전체 제약을 위배하지 않는다.
        
    - 즉, “안전하게 가능한 것부터 뽑는다”는 전략이 정확성을 보장한다.
        

---

## 5) 실전 포인트

- **여러 답이 가능**  
    → 위상 순서는 유일하지 않다.  
    → 입력 구조, 탐색 순서, 큐 처리 방식 등에 따라 결과가 달라질 수 있다.
    
- **사전식 최소(topological order with lexicographic minimality)**  
    → Kahn 알고리즘에서 큐 대신 **우선순위 큐(min-heap)** 를 쓰면 된다.
    
- **불연결 DAG**도 문제없음  
    → 시작 시 진입 차수 0인 정점이 여러 개라면 전부 후보로 넣고 진행하면 된다.
    
- **그래프 표현 영향**
    
    - 인접 리스트: $O(V+E)$로 빠름
        
    - 인접 행렬: 간선 스캔에 $O(V^2)$ 필요 → 큰 희소 그래프에는 비효율적
        

---

## 6) 응용 분야

- **선수 과목 → 후수 과목** 수강 순서 결정
    
- **빌드 시스템** (예: Make, Gradle)에서 라이브러리 의존성 해결
    
- **작업 스케줄링**: 선행 조건이 있는 작업들의 실행 순서
    
- **컴파일러**:
    
    - 의존 그래프 기반으로 코드 생성 순서 정렬
        
    - 컴파일 최적화 단계의 순서 제어
        
- **데이터 처리 파이프라인**: DAG 형태 워크플로우에서 실행 순서 결정
    

---

## 📌 한 줄 정리

**위상 정렬은 DAG에서만 가능하며, DFS 완료 시간 역순 또는 Kahn 알고리즘으로 $O(V+E)$에 구할 수 있다.**

---
