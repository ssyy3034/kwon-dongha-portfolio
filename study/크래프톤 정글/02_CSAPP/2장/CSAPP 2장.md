---
date: 2025-09-15
tags: [CS]
---

## CSAPP 2.1장 정보 저장(Information Storage) 요약

2.1장에서는 컴퓨터가 정보를 어떻게 저장하고 표현하는지에 대한 기본적인 방법을 다루고 있습니다. 모든 정보는 **비트(bits)의 연속**으로 표현되며, 이 비트들을 어떻게 해석하느냐(context)에 따라 의미가 달라진다는 것이 핵심 아이디어입니다.

---

### ### 16진수 표기법 (Hexadecimal Notation)

컴퓨터는 모든 정보를 0과 1의 **2진수**로 처리하지만, 사람이 2진수를 그대로 읽고 쓰기에는 너무 길고 불편합니다. 반면, **10진수**는 우리에게 익숙하지만 2진수와 바로 변환하기 어렵다는 단점이 있습니다.

- **16진수**는 이런 단점을 보완하기 위해 사용됩니다. 16진수는 4개의 비트를 하나의 숫자로 간결하게 표현할 수 있어 2진수와의 변환이 매우 쉽고, 10진수보다 훨씬 짧게 표기할 수 있습니다. 1
    
- 예를 들어, 16진수 `0x17`은 2진수 `00010111`과 같습니다. 16진수 한 글자(`1` -> `0001`, `7` -> `0111`)가 4비트에 해당하므로 변환이 직관적입니다.
    
- C언어에서는 숫자 앞에
    
    `0x`를 붙여 16진수임을 나타냅니다 (예: `0x1A`). 2
    

### ### 데이터 크기 (Data Sizes)

모든 컴퓨터는 데이터를 처리하는 기본 단위인 **워드(word)** 크기를 가집니다. 이 워드 크기는 가상 주소 공간의 최대 크기를 결정하며, 최근에는 32비트에서

**64비트**로 전환되는 추세입니다. 3

- **32비트 워드**: 약 4GB의 가상 주소 공간을 가집니다.
    
- **64비트 워드**: 약 16EB(엑사바이트)라는 훨씬 더 큰 주소 공간을 가집니다.
    
- C언어의 데이터 타입(char, int, long 등)이 차지하는 바이트 크기는 시스템과 컴파일러 설정에 따라 달라질 수 있습니다. 예를 들어
    
    `long` 타입은 32비트 프로그램에서는 4바이트, 64비트 프로그램에서는 8바이트를 차지하는 경우가 많습니다. 4
    

### ### 주소 지정과 바이트 순서 (Addressing and Byte Ordering)

여러 바이트로 구성된 데이터를 메모리에 저장할 때는 두 가지 규칙이 필요합니다.

1. **주소 지정**: 데이터의 주소는 여러 바이트 중 **가장 작은 주소**를 사용합니다. 예를 들어 4바이트
    
    `int` 변수가 주소 `0x100`에 저장된다면, 이 데이터는 `0x100`, `0x101`, `0x102`, `0x103`에 걸쳐 저장됩니다. 5
    
2. **바이트 순서**: 바이트를 저장하는 순서에 따라 **리틀 엔디안(Little Endian)**과 **빅 엔디안(Big Endian)**으로 나뉩니다.
    
    - **리틀 엔디안**: **가장 덜 중요한 바이트(LSB)**부터 저장하는 방식입니다. (예: Intel, AMD 프로세서)
        
    - **빅 엔디안**: **가장 중요한 바이트(MSB)**부터 저장하는 방식입니다. (예: IBM, Oracle 프로세서)
        
    - 예를 들어
        
        `0x01234567`을 저장할 때, 리틀 엔디안 시스템은 메모리에 `67 45 23 01` 순서로 저장하고, 빅 엔디안은 `01 23 45 67` 순서로 저장합니다. 6
        

### ### 문자열 및 코드 표현 (Representing Strings and Code)

- C언어에서
    
    **문자열**은 각 문자가 아스키(ASCII) 코드와 같은 표준 인코딩으로 표현되며, `NULL` 문자(`\0`)로 끝나는 문자 배열입니다. 7
    
- **기계어 코드** 역시 바이트의 연속으로 표현됩니다. 따라서 소스 코드가 같더라도 어떤 머신과 운영체제에서 컴파일했는지에 따라 기계어 코드는 달라지며, 플랫폼 간 호환성이 없습니다. 8
    

### ### 불 대수와 C언어 비트 연산 (Boolean Algebra and Bit Operations)

컴퓨터는 비트를 기반으로 정보를 처리하므로, 비트를 다루는 **불 대수(Boolean Algebra)**가 매우 중요합니다. C언어는 이러한 비트 연산을 직접 지원합니다.

- **비트 수준 연산**: `&`(AND), `|`(OR), `~`(NOT), `^`(XOR) 연산자는 비트 벡터의 각 비트에 대해 독립적으로 연산을 수행합니다. 9
    
- **논리 연산**: `&&`(AND), `||`(OR), `!`(NOT) 연산자는 0을 '거짓'으로, 0이 아닌 값을 '참'으로 간주하여 `1`(참) 또는 `0`(거짓)을 반환합니다. 또한, 첫 번째 인자만으로 결과를 알 수 있다면 두 번째 인자는 평가하지 않는
    
    **단축 평가(short-circuit evaluation)** 특징이 있습니다. 10
    
- **이동 연산 (Shift Operations)**: `<<`(왼쪽 이동)과 `>>`(오른쪽 이동) 연산이 있습니다. 오른쪽 이동은 **논리적 이동**(빈자리를 0으로 채움)과 **산술적 이동**(빈자리를 최상위 비트로 채움)으로 나뉩니다. C언어 표준에서는 부호 있는 수의 오른쪽 이동 방식을 명확히 정의하지 않지만, 대부분의 시스템은 산술적 이동을 사용합니다.

## CSAPP 2.2장 정수 표현 (Integer Representations) 요약

2.2장에서는 컴퓨터가 정수를 표현하는 두 가지 주요 방식인 **부호 없는 정수(Unsigned)**와 **2의 보수(Two's Complement)** 인코딩에 대해 설명합니다. 이 두 방식은 같은 비트 패턴을 사용하더라도 수를 해석하는 방식이 다르며, 이는 프로그래밍에서 예상치 못한 결과를 초래할 수 있습니다.

---

### ### 정수 데이터 타입 (Integral Data Types)

C언어는 다양한 크기의 정수 데이터 타입을 지원하며, 각 타입이 표현할 수 있는 값의 범위는 컴파일 방식(32비트/64비트)에 따라 달라질 수 있습니다1.

- **부호 없는 정수(Unsigned)**: 0 또는 양수만을 표현합니다.
    
- **부호 있는 정수(Signed)**: 음수, 0, 양수를 모두 표현하며, C언어에서는 기본값입니다.
    
- 2의 보수 표현 방식에서는 표현 가능한
    
    **음수 범위가 양수 범위보다 1만큼 더 큽니다**2. 예를 들어, 8비트
    
    `char`는 -128부터 +127까지 표현할 수 있습니다.
    

### ### 부호 없는 정수 인코딩 (Unsigned Encodings)

부호 없는 정수는 전통적인

**2진수 표기법**을 따릅니다3. w개의 비트로 구성된 비트 벡터

`[xw-1, xw-2, ..., x0]`는 다음과 같은 수식으로 해석됩니다.

`B2Uw(x) = x_i * 2^i` (i는 0부터 w-1까지) 4

- 각 비트 `x_i`는 `2^i`의 가중치를 가집니다.
    
- 0부터 `2^w - 1`까지의 모든 수를 고유하게 표현할 수 있습니다.
    

### ### 2의 보수 인코딩 (Two's-Complement Encodings)

대부분의 컴퓨터는 부호 있는 정수를 표현하기 위해

**2의 보수** 방식을 사용합니다5. 이 방식의 가장 큰 특징은 최상위 비트(MSB)를 **부호 비트(sign bit)**로 사용하며, 이 비트가

**음의 가중치**를 갖는다는 점입니다6.

`B2Tw(x) = -x_{w-1} * 2^{w-1} + Σ(x_i * 2^i)` (i는 0부터 w-2까지) 7

- 최상위 비트 `x_{w-1}`이 1이면 음수, 0이면 양수 또는 0을 의미합니다.
    
- 이 방식 때문에 표현 가능한 수의 범위가 비대칭적입니다(예:
    
    `TMin` = -2^(w-1), `TMax` = 2^(w-1) - 1)8.
    

### ### 부호 있는 정수와 부호 없는 정수 간 변환

C언어에서 부호 있는 타입과 부호 없는 타입 간에 캐스팅(casting)이 일어날 때, 대부분의 시스템은

**비트 패턴은 그대로 유지**하고 숫자 값의 해석만 바꿉니다9999.

- **`T2U` (2의 보수 → Unsigned)**: 음수는 큰 양수로 변환되고, 음수가 아닌 수는 그대로 유지됩니다. 변환 공식은 다음과 같습니다:
    
    - x < 0 이면 `x + 2^w`
        
    - x ≥ 0 이면 `x`
        
- **`U2T` (Unsigned → 2의 보수)**: `TMax`보다 작은 값은 그대로 유지되고, 그보다 큰 값은 음수로 변환됩니다.
    
- 이러한 암시적 캐스팅은 C언어의 관계 연산자(
    
    `<`, `>`)와 함께 사용될 때 예상치 못한 결과를 낳을 수 있으므로 주의해야 합니다10. 예를 들어
    
    `-1 < 0U` 라는 비교는 `-1`이 부호 없는 큰 수(UMax)로 변환되어 `거짓(false)`이 됩니다11.
    

### ### 비트 표현 확장 및 축소

데이터 타입을 더 큰 타입으로 변환할 때 값은 유지되어야 합니다.

- **영 확장 (Zero Extension)**: **부호 없는** 수를 더 큰 데이터 타입으로 변환할 때, 앞쪽에 0을 채워 넣습니다12.
    
- **부호 확장 (Sign Extension)**: **2의 보수** 수를 더 큰 데이터 타입으로 변환할 때, 부호 비트를 앞쪽에 복사하여 채워 넣습니다13.
    
- **숫자 축소 (Truncating)**: 숫자를 더 작은 데이터 타입으로 변환하면 상위 비트들이 버려집니다14.
    
    - 부호 없는 수의 경우: `x mod 2^k`와 같습니다.
        
    - 2의 보수 수의 경우: `U2T_k(x mod 2^k)`와 같습니다.


## CSAPP 2.3장 정수 연산 (Integer Arithmetic) 요약

2.3장에서는 컴퓨터가 정수를 가지고 덧셈, 곱셈, 나눗셈과 같은 연산을 수행하는 방식을 다룹니다. 컴퓨터의 연산은 유한한 비트 수 때문에 실제 정수 연산과 다른 특징을 보이며, 특히 **오버플로우(overflow)**가 발생할 수 있다는 점을 이해하는 것이 중요합니다.

---

### ### 부호 없는 덧셈 (Unsigned Addition)

두 부호 없는 수를 더할 때, 그 결과가 해당 데이터 타입이 표현할 수 있는 최대값을 초과하면

**오버플로우**가 발생합니다1.

- **모듈러 연산**: 컴퓨터의 부호 없는 덧셈은 결과값을 `2^w`로 나눈 나머지와 같습니다 (w는 비트 수)2. 예를 들어, 4비트 환경에서
    
    `9(1001) + 12(1100)`는 `21(10101)`이 되지만, 4비트만 유지되므로 `5(0101)`가 됩니다. 이는
    
    `21 mod 16 = 5`와 같습니다3.
    
- **오버플로우 탐지**: 덧셈 결과 `s`가 두 피연산자 `x`, `y`보다 작아지면 오버플로우가 발생한 것입니다4. (예:
    
    `s < x`).
    

### ### 2의 보수 덧셈 (Two's-Complement Addition)

2의 보수 덧셈은 부호 없는 덧셈과

**비트 수준에서는 동일하게 동작**하지만, 오버플로우를 판단하는 방식이 다릅니다5.

- **양수 오버플로우**: 두 양수를 더했는데 결과가 음수가 되는 경우입니다6.
    
- **음수 오버플로우**: 두 음수를 더했는데 결과가 양수가 되는 경우입니다7.
    
- **오버플로우 탐지**: 두 피연산자 `x`, `y`의 부호가 같은데 결과 `s`의 부호가 다른 경우 오버플로우가 발생한 것입니다8.
    

### ### 곱셈 (Multiplication)

컴퓨터에서의 곱셈 역시 결과가 워드 크기에 맞춰 **절단(truncate)**됩니다.

- **부호 없는 곱셈**: `(x * y) mod 2^w` 와 같습니다9.
    
- **2의 보수 곱셈**: 부호 없는 곱셈과 **비트 수준에서 동일한 결과**를 가집니다10.
    

### ### 상수에 의한 곱셈과 나눗셈 (Multiplying/Dividing by Constants)

컴파일러는 곱셈과 나눗셈 연산의 속도를 높이기 위해 다음과 같은 최적화를 수행합니다.

- **상수 곱셈**: 곱셈은 덧셈보다 느린 연산이므로, 컴파일러는 상수와의 곱셈을 **이동(shift)**과 **덧셈/뺄셈** 연산의 조합으로 변환합니다11.
    
    - 예를 들어,
        
        `x * 14`는 `x * (2^3 + 2^2 + 2^1)`이므로 `(x << 3) + (x << 2) + (x << 1)`로 계산할 수 있습니다12.
        
- **2의 거듭제곱으로 나누기**: 2의 거듭제곱으로 나누는 연산은 **오른쪽 이동(right shift)** 연산으로 최적화됩니다13.
    
    - **부호 없는 수**: **논리적 오른쪽 이동**을 사용합니다 (빈자리를 0으로 채움)14.
        
    - **2의 보수 수**: **산술적 오른쪽 이동**을 사용합니다 (빈자리를 부호 비트로 채움)15. 음수를 나눌 때는 올바른 반올림을 위해 **편향(biasing)**을 추가한 후 이동합니다.

## CSAPP 2.4장 부동소수점 (Floating Point) 요약

2.4장에서는 실수를 컴퓨터에서 표현하는 표준 방식인 **IEEE 부동소수점(Floating-Point)**에 대해 다룹니다. 정수 표현과 달리, 부동소수점은 매우 큰 수나 0에 매우 가까운 수를 표현할 수 있지만, 정밀도에 한계가 있어 근사치를 사용합니다.

---

### ### 분수 이진수 (Fractional Binary Numbers)

부동소수점을 이해하려면 먼저 2진 소수 표현법을 알아야 합니다. 10진 소수점과 마찬가지로 **2진 소수점(binary point)**을 사용하여 소수를 표현합니다.

- 2진 소수점 오른쪽의 각 자리는 `2⁻¹`(1/2), `2⁻²`(1/4), `2⁻³`(1/8) ... 와 같이 음의 거듭제곱 가중치를 가집니다.
    
- 예를 들어, `101.11₂`은 `4 + 0 + 1 + 1/2 + 1/4` 이므로 10진수로 `5.75` 입니다.
    
- 하지만 `1/3`이나 `1/5`과 같은 수는 2진 소수로 정확하게 표현할 수 없어 근사치로만 나타낼 수 있습니다. 이로 인해 작은 오차가 발생할 수 있습니다.
    

### ### IEEE 부동소수점 표현 (IEEE Floating-Point Representation)

IEEE 754 표준은 실수를 `V = (-1)ˢ × M × 2ᴱ` 형태로 표현합니다. 이 값을 비트 수준에서 저장하기 위해 세 부분으로 나눕니다.

1. **부호 (Sign, s)**: 1비트를 사용하여 양수(0)와 음수(1)를 결정합니다1.
    
2. **지수 (Exponent, E)**: `k`비트의 지수 필드는 2의 거듭제곱 값을 결정하여 수의 범위를 나타냅니다. 편향(bias)된 형태로 저장되어 실제 지수값은
    
    `E = e - Bias`로 계산됩니다2.
    
3. **가수 (Mantissa 또는 Fraction, M)**: `n`비트의 분수 필드는 수의 정밀도를 나타냅니다.
    

이 세 필드의 값에 따라 숫자는 다음 세 가지 경우로 나뉩니다.

- **정규화된 값 (Normalized)**: 가장 일반적인 경우로, 지수 필드가 모두 0이거나 모두 1이 아닐 때입니다3. 이때 가수
    
    `M`은 `1 + f` (f는 분수 필드 값)로 계산되어 정밀도를 1비트 더 확보하는 효과를 냅니다.
    
- **비정규화된 값 (Denormalized)**: 지수 필드가 모두 0일 때 사용되며, 0에 매우 가까운 수를 표현하기 위해 사용됩니다4. 이 경우 가수
    
    `M`은 `f`와 같습니다.
    
- **특수 값 (Special Values)**: 지수 필드가 모두 1일 때 사용됩니다.
    
    - 분수 필드가 0이면 **무한대(infinity)**를 나타냅니다5.
        
    - 분수 필드가 0이 아니면 **NaN(Not a Number)**을 나타냅니다6. (예:
        
        `√-1`)
        

### ### 반올림 (Rounding)

부동소수점은 실수를 근사적으로 표현하므로, 표현 가능한 가장 가까운 값으로 **반올림**하는 과정이 필요합니다. IEEE 표준은 네 가지 반올림 모드를 정의하며, 기본 모드는 **짝수 반올림(Round-to-even)**입니다.

- **짝수 반올림**: 두 표현 가능한 값의 정확히 중간에 있는 값을 반올림할 때, 결과의 최하위 비트를 짝수(0)로 만드는 방향으로 반올림합니다. 이 방식은 통계적 편향을 최소화하는 장점이 있습니다.
    

### ### 부동소수점 연산

부동소수점 연산은 일반적인 정수나 실수 연산과 다른 수학적 속성을 가집니다.

- **결합법칙이 성립하지 않음**: `(3.14 + 1e20) - 1e20`은 `0.0`이 되지만, `3.14 + (1e20 - 1e20)`은 `3.14`가 됩니다7. 이는 반올림으로 인한 정밀도 손실 때문에 발생합니다.
    
- **분배법칙도 성립하지 않음**: `1e20 * (1e20 - 1e20)`은 `0.0`이지만, `1e20*1e20 - 1e20*1e20`은 `NaN`이 될 수 있습니다8.
    
- 이러한 특성 때문에 컴파일러는 부동소수점 연산의 순서를 함부로 바꾸지 않으며, 프로그래머는 연산 순서에 주의해야 합니다.
    

### ### C언어의 부동소수점

C언어는

`float`(단일 정밀도, 4바이트)와 `double`(배 정밀도, 8바이트) 데이터 타입을 제공하며, 이는 대부분의 시스템에서 IEEE 754 표준을 따릅니다9. 정수와 부동소수점 간의 캐스팅은 값을 완전히 바꾸며, 큰 부동소수점 수를 정수로 변환할 때 오버플로우가 발생하여 예상치 못한 음수 값이 될 수도 있습니다.