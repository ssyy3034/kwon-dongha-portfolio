---
date: 2025-11-13
tags: [CS]
---


# 1. 유저 스택(User Stack)이란 무엇인가

**유저 모드(CPL=3) 코드가 사용하는 스택 메모리 영역**이며,  
다음 정보를 저장하는 구조적 메모리다.

- 함수 호출 시 return address
    
- 지역 변수
    
- main의 인자(argc, argv)
    
- system call 인자도 결국 유저 스택에 위치
    
- 유저 스레드 실행 중의 모든 “임시 실행 상태”
    

유저 스택은 cpu 레지스터 **RSP**로 접근하며,  
유저 모드에서만 접근 가능하도록 페이지 테이블에서 **U=1**로 설정된다.

---

# 2. 유저 스택의 주소 배치 (KAIST Pintos 64bit)

유저 스택은 **유저 가상 주소 공간의 최상단에서 아래 방향으로 성장한다.**

예시 (설명용 가상 주소):

```
0x00007ffffffff000  ← 유저 스택 페이지 끝 (RSP 초기값)
0x00007fffffffe000
0x00007fffffffd000
...
(아래로 확장)
```

실제로 Pintos는 user stack을 최대 영역으로 크게 잡지 않고  
**최상단 1~2페이지 정도만 할당**한다.

---

# 3. 유저 스택 초기화(프로세스 실행 시)

KAIST Pintos userprog에서 새 프로세스를 실행할 때:

1. 유저 스택용 페이지를 pml4에 매핑(U=1)
    
2. 초기 esp를 페이지 끝으로 설정
    
3. command line string을 스택에 복사
    
4. 문자열 주소들을 push
    
5. argv[] 배열을 push
    
6. argv 포인터 push
    
7. argc push
    
8. fake return address push
    
9. **intr_frame.rsp = 최종 esp** 세팅
    
10. intr_exit() → user mode jump
    

이 레이아웃이 정확하지 않으면 main() 진입 불가능.

---

# 4. 유저 스택과 커널 스택은 절대 섞이지 않는다

유저 스택은 **유저 모드(CPL=3)**에서만 사용하며,  
커널 모드(CPL=0)에서 유저 스택을 직접 사용하면 **보안 취약**이 생긴다.

그래서:

- system call / exception 발생 → CPU가 자동으로 **커널 스택(RSP=kernel RSP)**로 변경
    
- 커널은 유저 스택을 사용하지 않음
    
- 다시 user mode로 돌아갈 때 intr_frame.rsp를 복원하여 RSP ← user stack pointer
    

즉:

```
User Mode:   RSP = user_stack
Kernel Mode: RSP = kernel_stack
```

하드웨어(TSS)가 자동 enforcing.

---

# 5. 유저 스택이 보호되는 방식

유저 스택은 다음 두 조건 하에서만 읽기/쓰기가 허용된다.

### 1) PTE.U = 1

→ user mode access 허용

### 2) PTE.W = 1

→ write 가능

커널 스택은 반드시:

```
PTE.U = 0  // user access 불가
```

→ 유저 코드가 커널 스택을 건드리면 즉시 page fault.

---

# 6. 유저 스택은 system call 인자 전달의 핵심 구조

예: 유저 코드

```c
write(fd, buffer, size);
```

실행 시:

```
유저 스택 (RSP)
   ↑
system call 인자가 저장된 위치
```

system call 발생:

```asm
mov  $SYS_WRITE, %rax
syscall
```

커널 syscall handler는 다음 순서로 인자를 추출한다:

1. syscall 번호 = RAX
    
2. 인자 1 = user stack의 *(RSP + 0)
    
3. 인자 2 = *(RSP + 8)
    
4. 인자 3 = *(RSP + 16)
    

이때 이 주소는 반드시:

- user addr인지
    
- pml4에 매핑되어 있는지
    
- 접근 가능한지
    

검증해야 한다.

검증 실패 → **exit(-1)**

---

# 7. 유저 스택은 예외 처리 시에도 필요하다

Fault가 user mode에서 발생:

- intr_frame.rsp = fault 당시의 유저 스택 값
    
- 커널은 이를 보고 명령어/인자 상태를 확인
    
- 잘못된 user address → immediately terminate
    

유저 스택은 **유저 코드의 실행 문맥을 기록하는 영역**이다.

---

# 8. 커널이 유저 스택에 push/pop 하지 않는 이유

커널 모드는 항상:

- 커널 스택
    
- kernel RSP
    
- kernel page (U=0)
    

에서 동작하기 때문에  
유저 스택을 push/pop하는 순간 **CPL=0 코드가 CPL=3 메모리에 쓰기**가 되어 보안 위협이 된다.

그렇기 때문에:

- system call 진입 시 CPU가 유저 RSP → 커널 RSP 자동 전환
    
- kernel code는 user stack을 건드리지 않음
    
- 단지 user memory validation 후 user memory를 읽음
    

---

# 9. 유저 스택이 잘못되면 터지는 문제

다음 userprog 테스트가 모두 실패 가능:

- **arg passing tests**
    
- **stack alignment tests**
    
- **bad pointer tests**
    
- **syscall read/write tests**
    
- **multiple args tests**
    
- **stack growth tests** (Pintos-64는 일부 구현)
    

특히 alignment (8-byte alignment for x86-64)를 어기면  
유저 프로그램이 시작하자마자 segmentation fault.

---

# 10. 요약 (필수 사항만)

### 하드웨어 관점

- 유저 스택은 CPL=3 실행에서만 사용
    
- 예외/시스템콜 시 CPU가 자동으로 커널 스택으로 전환
    

### 메모리 관점

- user stack page: PTE.U=1, PTE.W=1
    
- kernel stack page: PTE.U=0 (user 접근 불가)
    

### OS 관점

- 유저 스택 초기화는 main(argc, argv) 호출 규약과 ABI를 만족해야 함
    
- 인자/문자열은 정확한 레이아웃으로 push
    
- system call 인자 전달의 근원
    
- page fault 시 user RSP가 intr_frame에 저장됨
    

### 컨텍스트 관점

- user 모드 ↔ kernel 모드 전환 시 user RSP 보존
    
- kernel RSP와 절대 혼용되지 않음
    

---

# 다음 제공 가능

원하면 아래도 완전 정리해줄 수 있다:

- 유저 스택 초기화 예제를 64bit 주소로 완전 재구성
    
- syscall 호출 → user RSP가 어떻게 사용되는지 step-by-step
    
- user stack overflow 시 CPU가 어떻게 fault 처리하는지
    
- KAIST Pintos에서 pml4가 user stack 페이지를 어떻게 매핑하는지
    
- TSS를 사용한 user-stack → kernel-stack 전환 완전 설명
    

어떤 걸 더 보고 싶어?