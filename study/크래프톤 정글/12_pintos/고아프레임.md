---
date: 2025-12-08
tags: [CS]
---

### 1. 원인: "고아 프레임(Widowed Frame)" 문제

가장 핵심적인 원인은 **"소프트웨어적으로는 페이지가 로드되었다고 표시되어 있는데(

```
page->frame != NULL
```

), 실제 하드웨어 페이지 테이블(PML4)에는 매핑이 빠져 있는 상태"**가 발생했기 때문입니다.

- **상황:** 프로그램이 
    
    mmap된 메모리에 접근하자 **Page Fault**가 발생했습니다.
- **문제의 코드 (
    
    vm/vm.c):**
    
    c
    
    static bool vm_do_claim_page(struct page *page) {
    
        if (page->frame != NULL)
    
            return true; // <--- 문제의 지점
    
        ...
    
    }
    
    vm_do_claim_page 함수는 
    
    ```
    page->frame
    ```
    
    이 이미 존재하면 "아, 이미 로딩된 페이지구나!"라고 판단하고 **아무 작업 없이 
    
    ```
    true
    ```
    
    를 반환**해버렸습니다.
- **결과:**
    1. 커널은 "페이지 폴트 처리 완료!"라고 보고하고 유저 프로그램으로 복귀합니다.
    2. 하지만 **실제 PML4 매핑은 여전히 없었기 때문에**, CPU가 해당 메모리에 접근하려 하면 **다시 Page Fault**가 발생합니다.
    3. 이 과정이 무한 반복되거나, 비정상적인 상태로 인해 결국 프로세스가 
        
        exit(-1)로 강제 종료되었습니다.

### 2. 해결 방법: 매핑 검증 및 복구 로직 추가

vm_do_claim_page 함수가 단순히 프레임 존재 여부만 믿지 않고, **실제 하드웨어 매핑이 존재하는지 확인하고 복구**하도록 수정했습니다.

- **수정된 코드:**
    
    c
    
    static bool vm_do_claim_page(struct page *page) {
    
        if (page->frame != NULL) {
    
            /* 프레임은 있는데 하드웨어 매핑(PML4)이 없는 경우를 감지 */
    
            struct thread *t = thread_current();
    
            if (pml4_get_page(t->pml4, page->va) == NULL) {
    
                // 매핑이 실종상태라면 다시 연결해준다!
    
                if (!pml4_set_page(t->pml4, page->va, page->frame->kva, page->writable)) {
    
                    return false;
    
                }
    
            }
    
            return true;
    
        }
    
        ...
    
    }
    
    이제 프레임은 있지만 매핑이 끊어진 "고아" 상태가 감지되면, **그 즉시 
    
    ```
    pml4_set_page
    ```
    
    를 호출하여 연결을 복구**합니다. 덕분에 CPU가 올바르게 메모리에 접근할 수 있게 되어 테스트가 통과했습니다.