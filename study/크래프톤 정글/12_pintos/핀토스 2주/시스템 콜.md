---
date: 2025-11-13
tags: [CS]
---


# 1. SYSTEM CALL 이란?

**유저 모드(CPL=3) 프로그램이 커널 모드(CPL=0) 기능을 요청하는 정식 메커니즘.**

유저 프로그램은:

- 파일 읽기/쓰기
    
- 프로세스 생성
    
- 메모리 매핑
    
- 시간 정보
    
- 종료(exit)
    

같은 동작을 직접 할 수 없다.  
커널이 대신 수행해야 한다.

그러므로 시스템 콜은 다음 두 기능을 가진다:

1. **특권 상승(Privilege transition)**: CPL=3 → CPL=0
    
2. **제어권 전환(Control transfer)**: 유저 코드 → 커널의 시스템 콜 엔트리
    

---

# 2. KAIST Pintos는 `syscall` 명령을 사용 (x86-64 전용)

32bit Pintos(original)는 `int 0x30` 인터럽트를 쓴다.  
하지만 KAIST Pintos는 64bit long mode이므로 **`syscall` 명령**으로 시스템 콜을 한다.

`syscall`의 특징:

- 빠르다 (인터럽트보다 오버헤드 작음)
    
- CPU가 특정 레지스터(RCX, R11 등)에 자동 저장
    
- 특권 전환 + RIP 변경 + RSP 전환을 하드웨어가 자동 수행
    

---

# 3. SYSTEM CALL ABI (x86-64)

시스템 콜은 함수 호출과 ABI가 다르다.

### 전달 규칙:

|내용|레지스터|
|---|---|
|시스템 콜 번호|**RAX**|
|1번 인자|**RDI**|
|2번 인자|**RSI**|
|3번 인자|**RDX**|
|4번 인자|**R10**|
|5번 인자|**R8**|
|6번 인자|**R9**|

복귀값은:

- **RAX** 에 저장한다.
    

이 규칙은 Linux x86-64 syscall ABI와 거의 동일하다.

---

# 4. SYSTEM CALL 발생 흐름 (User → Kernel)

예:

```c
write(fd, buffer, size);
```

유저 모듈(lib)이 내부적으로 이렇게 구현한다(개념적):

```asm
mov $SYS_WRITE, %rax
mov fd,      %rdi
mov buffer,  %rsi
mov size,    %rdx
syscall
```

### `syscall` 명령이 실행되면 CPU는 자동으로 다음을 수행한다:

1. RCX ← user RIP (복귀 지점 저장)
    
2. R11 ← RFLAGS (복귀 후 RFLAGS 복구)
    
3. CPL=0 진입 (특권 상승)
    
4. RIP ← IA32_LSTAR MSR에 설정된 kernel-entry 주소
    
5. RSP ← TSS에 저장된 kernel RSP (스택 자동 전환)
    
6. CS, SS 세그먼트 자동 교체
    

→ 커널 시스템 콜 엔트리 코드에서 실행 시작.

---

# 5. 커널에서 SYSTEM CALL 인자 추출

커널은 진입 시 intr_frame(혹은 CPU saved state 구조)을 만든다.

그러면:

```c
uint64_t sysno = f->RAX;
uint64_t arg1  = f->RDI;
uint64_t arg2  = f->RSI;
uint64_t arg3  = f->RDX;
...
```

이런 식으로 인자를 획득한다.

그리고 커널이 제공하는 시스템 콜 테이블에서  
`syscall_handlers[sysno]` 를 호출한다.

---

# 6. 유저 주소 검증 (매우 중요)

system call 인자로 들어온 pointer는 **유저 메모리**를 가리킨다.

커널은 반드시:

```
pml4_get_page(current->pml4, addr) != NULL
```

을 확인해야 한다.

검증 단계:

1. 주소가 user space 범위인지?
    
2. 해당 페이지가 매핑돼 있는지?
    
3. 접근 가능한 권한인지 (U=1)?
    
4. 문자열/버퍼는 끝까지 valid인지?
    

하나라도 실패하면:

```
exit(-1);
```

이것이 Pintos userprog의 핵심 안정성 요구 사항.

---

# 7. SYSTEM CALL 처리

유저의 write 요청이면 내부적으로:

1. 파일 디스크립터 테이블에서 fd → struct file* 찾기
    
2. user buffer의 매핑/권한 확인
    
3. 실제 파일 쓰기
    
4. 결과값(RAX) 세팅
    

예:

```c
f->RAX = bytes_written;
```

---

# 8. SYSTEM CALL 복귀 (Kernel → User)

커널은 system call handler 실행이 끝나면:

```
intr_exit();
```

을 호출한다.

`intr_exit()`는 low-level assembly로:

- RSP ← user RSP (intr_frame에서 복원)
    
- RIP ← user RIP (RCX에 저장된 복귀 지점)
    
- RFLAGS ← R11의 값
    
- CS/SS 복원
    
- `iretq` 수행 → user mode 재진입
    

결과적으로 프로그램은 레지스터에 결과값을 받은 채  
`syscall` 다음 명령어에서 계속 실행한다.

---

# 9. SYSTEM CALL의 중요한 역할 요약

1. **권한 전환 (CPL=3 → CPL=0)**
    
2. **메모리 보호 적용**
    
    - 커널 페이지(U=0)에 유저가 접근 불가
        
3. **주소 공간 분리(PML4 기반)**
    
4. **프로세스 ↔ 커널 통신 인터페이스**
    
5. **정확한 ABI 규약**으로 인자 전달
    
6. **커널 스택 자동 전환**
    
7. **세이프티 체크 필수** (user pointer validation)
    

---

# 10. 전체 흐름을 그림으로 표현

```
   User code
------------------------------
RAX = system call number
RDI, RSI, RDX = arguments
syscall
------------------------------
CPU:
  RCX = RIP(user)
  R11 = RFLAGS
  change to CPL=0
  switch to kernel stack
  RIP = syscall_entry
------------------------------
Kernel:
  f->RAX, f->RDI...  (extract args)
  validate user pointers (pml4_get_page)
  handle syscall
  f->RAX = return value
------------------------------
iretq → User mode 복귀
RAX = result
continue execution at RCX
```

---

# 11. 정리 (핵심 5줄)

- system call은 **유저 모드에서 커널로 진입하는 공식 경로**
    
- KAIST Pintos는 64bit `syscall` 명령을 사용
    
- 인자는 **레지스터(RDI, RSI, RDX, …)** 로 전달
    
- CPU가 **권한 전환 + 스택 전환**을 자동 처리
    
- 커널은 intr_frame에서 인자 읽고, 작업 후 RAX로 반납, iretq로 복귀
    