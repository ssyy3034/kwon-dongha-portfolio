---
date: 2025-11-01
tags: [Network]
---


# 11.4 소켓 인터페이스 (The Sockets Interface)

## 개요

**소켓 인터페이스(Sockets Interface)** 는 네트워크 애플리케이션을 만들기 위해 유닉스 I/O 함수와 함께 사용되는 함수들의 집합입니다. 클라이언트와 서버는 이 인터페이스를 통해 연결을 수립하고, 소켓 디스크립터(Socket Descriptor)를 통해 서로 데이터를 읽고 씁니다.

`그림 11.12`는 소켓 인터페이스를 사용한 클라이언트-서버 통신의 전체적인 흐름을 보여주는 로드맵입니다.

- **서버 측**: `getaddrinfo` → `socket` → `bind` → `listen` → `accept` 루프
    
- **클라이언트 측**: `getaddrinfo` → `socket` → `connect`
    
- **데이터 교환**: `rio_writen`, `rio_readlineb`
    
- **연결 종료**: `close`
    

---

## 11.4.1 소켓 주소 구조체 (Socket Address Structures)

커널은 소켓을 통신의 종단점(endpoint)으로 인식하며, 프로그래머에게는 파일 디스크립터 형태로 제공합니다. 인터넷 통신에서 이 종단점의 주소 정보는 `sockaddr_in` 구조체에 저장됩니다.

C

```
/* IP 소켓 주소 구조체 */
struct sockaddr_in {
    uint16_t      sin_family; /* 프로토콜 체계 (항상 AF_INET) */
    uint16_t      sin_port;   /* 네트워크 바이트 순서의 포트 번호 */
    struct in_addr sin_addr;   /* 네트워크 바이트 순서의 IP 주소 */
    unsigned char sin_zero[8];/* sockaddr 구조체 크기에 맞추기 위한 패딩 */
};

/* 일반적인 소켓 주소 구조체 (connect, bind, accept 용) */
struct sockaddr {
    uint16_t sa_family; /* 프로토콜 체계 */
    char     sa_data[14];/* 주소 데이터 */
};
```

- `sockaddr_in`: 인터넷(IP) 통신 전용 구조체입니다.
    
    - `sin_family`: 항상 `AF_INET` (IPv4를 의미)으로 설정됩니다.
        
    - `sin_port`, `sin_addr`: 포트 번호와 IP 주소는 반드시 **네트워크 바이트 순서(Big-Endian)** 로 저장되어야 합니다.
        
- `sockaddr`: `connect`, `bind`, `accept` 같은 함수들은 다양한 프로토콜(IP, Unix domain 등)을 지원해야 합니다. 이 함수들은 어떤 프로토콜의 주소 구조체든 받을 수 있도록 **일반적인(generic) `sockaddr` 구조체 포인터를 인자로 받습니다**. 따라서 프로그래머는 `sockaddr_in` 구조체를 `sockaddr` 타입으로 **형 변환(casting)** 하여 함수에 전달해야 합니다.
    

---

## 11.4.2 `socket` 함수 - 소켓 생성

클라이언트와 서버 모두 통신을 시작하기 위해 `socket` 함수를 호출하여 **소켓 디스크립터**를 생성합니다.

C

```
#include <sys/types.h>
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// 성공 시 음수가 아닌 디스크립터, 실패 시 -1 리턴
```

- 이 함수로 생성된 디스크립터는 아직 읽고 쓸 수 없는 **'부분적으로만 열린' 상태**이며, 이후의 과정은 클라이언트인지 서버인지에 따라 달라집니다.
    
- `domain`: `AF_INET` (IPv4) 또는 `AF_INET6` (IPv6)
    
- `type`: `SOCK_STREAM` (연결 지향 TCP) 또는 `SOCK_DGRAM` (비연결 지향 UDP)
    
- **Best Practice**: 이 인자들을 직접 하드코딩하기보다, 이후에 배울 `getaddrinfo` 함수를 통해 자동으로 얻어와 프로토콜에 독립적인 코드를 작성하는 것이 좋습니다.
    

---

## 11.4.3 `connect` 함수 - 클라이언트의 연결 요청

클라이언트는 `connect` 함수를 호출하여 서버와의 연결을 수립합니다.

C

```
#include <sys/socket.h>

int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
// 성공 시 0, 실패 시 -1 리턴
```

- `clientfd`: `socket()`으로 생성한 클라이언트의 소켓 디스크립터.
    
- `addr`: 연결하려는 서버의 소켓 주소 정보(`sockaddr_in` 구조체).
    
- 이 함수는 **연결이 성공적으로 수립되거나 오류가 발생할 때까지 블록(block)됩니다**.
    
- 성공하면, `clientfd`는 이제 데이터를 읽고 쓸 수 있는 상태가 됩니다.
    

---

## 11.4.4 `bind` 함수 - 서버의 주소 할당

서버는 `bind` 함수를 통해 소켓 디스크립터에 특정 소켓 주소(IP, 포트)를 연결(associate)합니다. "이 `sockfd` 디스크립터는 `addr`에 명시된 IP와 포트로 들어오는 요청을 처리하겠다"고 커널에 등록하는 과정입니다.

C

```
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
// 성공 시 0, 실패 시 -1 리턴
```

---

## 11.4.5 `listen` 함수 - 서버의 수신 대기 상태 전환

기본적으로 `socket()`으로 생성된 디스크립터는 '능동적 소켓(active socket)', 즉 클라이언트용으로 가정됩니다. 서버는 `listen` 함수를 호출하여 이 디스크립터를 **'수동적 리슨 소켓(listening socket)'**으로 변환해야 합니다.

C

```
#include <sys/socket.h>

int listen(int sockfd, int backlog);
// 성공 시 0, 실패 시 -1 리턴
```

- 이 함수는 `sockfd`를 클라이언트의 연결 요청을 받을 수 있는 상태로 만듭니다.
    
- `backlog`: 커널이 연결 요청을 거부하기 전까지 대기 큐(queue)에 쌓아둘 수 있는 최대 연결 요청의 개수에 대한 힌트입니다.
    

---

## 11.4.6 `accept` 함수 - 서버의 연결 수락

서버는 `listen` 상태의 소켓을 가지고 `accept` 함수를 호출하여, 클라이언트의 연결 요청이 들어올 때까지 기다립니다.

C

```
#include <sys/socket.h>

int accept(int listenfd, struct sockaddr *addr, int *addrlen);
// 성공 시 음수가 아닌 연결 디스크립터, 실패 시 -1 리턴
```

- `listenfd`: `listen()`을 호출한 리슨 소켓 디스크립터.
    
- `addr`: 접속한 클라이언트의 소켓 주소 정보가 채워질 버퍼.
    
- **리턴 값**: **새로 생성된 '연결 디스크립터(connected descriptor)'**.
    

#### 리슨 디스크립터 vs. 연결 디스크립터

이 둘의 차이를 이해하는 것이 매우 중요합니다.

- **리슨 디스크립터 (`listenfd`)**:
    
    - 서버의 생명주기 동안 한번만 생성되어 계속 존재합니다.
        
    - 오직 클라이언트의 **연결 요청을 받는 관문(end point) 역할**만 합니다.
        
- **연결 디스크립터 (`connfd`)**:
    
    - 서버가 **연결 요청을 수락할 때마다 새로 생성**됩니다.
        
    - 클라이언트와 서버 간의 **실제 데이터 통신을 위한 종단점**입니다.
        
    - 서버가 클라이언트에 대한 서비스를 마치면 닫힙니다.
        

---

## 11.4.7 호스트 및 서비스 변환 (Host and Service Conversion)

이 섹션은 사람이 사용하는 주소 표현(호스트 이름, 서비스 이름)과 컴퓨터가 사용하는 바이너리 주소 구조체 간의 변환을 담당하는 최신 함수들을 소개합니다. 이 함수들은 기존의 `gethostbyname`, `getservbyname` 같은 구식 함수들의 재진입성(reentrancy) 문제와 프로토콜 종속성 문제를 해결합니다.

### `getaddrinfo` 함수

**이름/서비스 → 소켓 주소 구조체 변환**

`getaddrinfo`는 호스트 이름, 서비스(포트) 이름 문자열을 받아, 소켓 통신에 즉시 사용 가능한 소켓 주소 구조체의 연결 리스트(linked list)를 반환합니다.

C

```
#include <netdb.h>

int getaddrinfo(const char *host, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **result);
// 성공 시 0, 실패 시 에러 코드 리턴

void freeaddrinfo(struct addrinfo *result);
// getaddrinfo가 할당한 메모리 해제

const char *gai_strerror(int errcode);
// 에러 코드를 문자열로 변환
```

- **`host`**: 도메인 이름 (예: `"google.com"`) 또는 숫자 IP 주소 문자열 (예: `"127.0.0.1"`).
    
- **`service`**: 서비스 이름 (예: `"http"`) 또는 10진수 포트 번호 문자열 (예: `"80"`).
    
- **`hints`**: `getaddrinfo`가 반환할 주소의 종류를 필터링하기 위한 힌트 구조체 포인터입니다.
    
    - `ai_family`: `AF_INET`(IPv4), `AF_INET6`(IPv6) 등으로 프로토콜 체계를 제한합니다.
        
    - `ai_socktype`: `SOCK_STREAM`(TCP) 등으로 소켓 타입을 제한합니다.
        
    - `ai_flags`: `AI_PASSIVE` (서버용, 와일드카드 주소 반환), `AI_ADDRCONFIG` (호스트에 설정된 프로토콜만 반환) 등 추가적인 동작을 제어합니다.
        
- **`result`**: 결과로 생성된 `addrinfo` 구조체 연결 리스트의 시작을 가리키는 포인터입니다.
    

`getaddrinfo`의 가장 큰 장점은 반환된 `addrinfo` 구조체의 필드들을 그대로 `socket`, `bind`, `connect` 함수에 전달할 수 있다는 점입니다. 이 덕분에 프로토콜에 독립적인 코드를 매우 깔끔하게 작성할 수 있습니다.

### `getnameinfo` 함수

**소켓 주소 구조체 → 이름/서비스 변환**

`getnameinfo`는 `getaddrinfo`의 역함수입니다. 바이너리 소켓 주소 구조체를 받아 사람이 읽을 수 있는 호스트 이름과 서비스 이름 문자열로 변환합니다.

C

```
#include <netdb.h>

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *service, size_t servlen, int flags);
// 성공 시 0, 실패 시 에러 코드 리턴
```

- **`sa`, `salen`**: 변환할 소켓 주소 구조체와 그 크기입니다.
    
- **`host`, `hostlen`**: 호스트 이름을 저장할 버퍼와 그 크기입니다.
    
- **`service`, `servlen`**: 서비스 이름을 저장할 버퍼와 그 크기입니다.
    
- **`flags`**: `NI_NUMERICHOST`(도메인 이름 대신 숫자 IP 주소 반환), `NI_NUMERICSERV`(서비스 이름 대신 숫자 포트 번호 반환) 등으로 동작을 제어할 수 있습니다.
    

---

## 11.4.8 소켓 인터페이스 헬퍼 함수 (Helper Functions)

`getaddrinfo`와 소켓 인터페이스 함수들을 직접 사용하는 것은 다소 복잡할 수 있습니다. 교재에서는 이를 편리하게 사용하기 위해 두 개의 고수준 헬퍼 함수 `open_clientfd`와 `open_listenfd`를 제공합니다.

### `open_clientfd` 함수

클라이언트가 서버와의 연결을 수립하기 위해 사용하는 함수입니다.

C

```
int open_clientfd(char *hostname, char *port);
// 성공 시 디스크립터, 실패 시 -1 리턴
```

이 함수는 내부적으로 `getaddrinfo`를 호출하여 접속할 서버의 주소 리스트를 가져온 뒤, 리스트를 순회하며 `socket()`과 `connect()`를 시도합니다. 연결에 성공하면 루프를 빠져나와 성공적으로 연결된 소켓 디스크립터를 반환하고, 모든 주소에 대해 연결이 실패하면 -1을 반환합니다.

### `open_listenfd` 함수

서버가 클라이언트의 연결 요청을 받을 준비를 하기 위해 사용하는 함수입니다.

C

```
int open_listenfd(char *port);
// 성공 시 리슨 디스크립터, 실패 시 -1 리턴
```

이 함수는 내부적으로 `getaddrinfo`를 `AI_PASSIVE` 플래그와 함께 호출하여 서버용 주소 리스트를 가져온 뒤, 리스트를 순회하며 `socket()`과 `bind()`를 시도합니다. 성공하면 `listen()`을 호출하여 소켓을 리슨 상태로 전환하고, 최종적으로 생성된 리슨 디스크립터를 반환합니다. 중간에 `setsockopt` 함수를 사용하여, 서버 재시작 시 "Address already in use" 에러를 방지하는 옵션을 설정합니다.

---

## 11.4.9 예제: 에코 클라이언트와 서버 (Example Echo Client and Server)

소켓 인터페이스를 학습하는 가장 좋은 방법은 예제 코드를 분석하는 것입니다.

### 에코 클라이언트

`main` 함수는 호스트 이름과 포트 번호를 인자로 받아 `open_clientfd`를 호출하여 서버와 연결하고 연결된 소켓 디스크립터를 얻습니다. 그 후 루프에 진입하여 표준 입력에서 한 줄을 읽고(`Fgets`), 읽은 내용을 서버로 보내고(`Rio_writen`), 서버가 되돌려 보낸 메아리를 다시 읽어(`Rio_readlineb`) 표준 출력에 출력하는(`Fputs`) 과정을 반복합니다. 표준 입력에서 EOF(Ctrl+D)를 만나면 루프가 종료되고, `close(clientfd)`를 호출하여 연결을 닫고 서버에 EOF를 알립니다.

### 에코 서버

이 예제는 한 번에 하나의 클라이언트만 처리하는 **반복 서버(Iterative Server)**입니다.

- main 루틴:
    
    main 함수는 포트 번호를 인자로 받아 open_listenfd를 호출하여 리슨 디스크립터를 생성합니다. 그 후 무한 루프에 진입하여 accept를 호출해 클라이언트의 연결을 기다립니다. 연결이 되면 새로운 **연결 디스크립터(connfd)**를 반환받고, 접속한 클라이언트의 정보를 출력한 뒤 echo(connfd) 함수를 호출하여 클라이언트 서비스를 처리합니다. echo 함수가 리턴하면(클라이언트가 연결을 끊으면), close(connfd)로 연결 디스크립터를 닫고 다시 루프의 처음으로 돌아가 다음 클라이언트를 기다립니다.
    
- echo 함수:
    
    연결 디스크립터 connfd를 인자로 받아 루프에 진입합니다. 클라이언트로부터 한 줄의 텍스트를 읽고(Rio_readlineb), 만약 0이 반환되면(EOF, 클라이언트가 연결을 끊음) 루프를 종료합니다. 그렇지 않으면 읽은 내용을 그대로 클라이언트에게 다시 보냅니다(Rio_writen).