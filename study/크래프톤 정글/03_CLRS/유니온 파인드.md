---
date: 2025-09-19
category: 알고리즘
week: 38
tags: [Algorithm, CLRS, 그래프이론, 알고리즘, 유니온파인드, 최소스패닝트리]
---

# 🟦 유니온 파인드 (Union-Find) 정리

## 1) 정의

- 여러 개의 **서로소(disjoint) 집합**을 관리하는 자료구조
    
- 지원 연산
    
    - **MAKE-SET(x)**: 원소 `x`를 자기 자신만 포함하는 집합으로 초기화
        
    - **FIND(x)**: `x`가 속한 집합의 **대표자(root)** 반환
        
    - **UNION(x, y)**: 두 집합을 합쳐서 하나의 집합으로 만듦
        

👉 이름 그대로 **Union + Find**가 핵심

---

## 2) 동작 원리

- 집합을 **트리 구조**로 표현
    
- 각 집합은 **루트 노드**가 대표자 역할
    
- `FIND(x)` → 루트까지 따라가서 대표자를 반환
    
- `UNION(x, y)` → 두 집합의 루트를 찾아 한쪽 루트를 다른 쪽 밑에 붙임
    

---

## 3) 최적화 기법

1. **Union by Rank / Size**
    
    - 트리 높이(rank)나 원소 개수(size)를 기준으로
        
    - **작은 트리를 큰 트리 밑에 붙임**(루트 바로 밑에)
        
    - 트리의 불필요한 성장을 막음
        
2. **Path Compression (경로 압축)**
    
    - `FIND(x)` 호출 시, 지나온 모든 노드를 루트에 직접 연결
        
    - 이후 같은 집합을 찾을 때 탐색이 거의 한 번에 끝남
        

---

## 4) 시간 복잡도

- 단순 구현: 최악 $O(n)$
    
- **Union by Rank + Path Compression** 적용:
    
    O(m⋅α(n))O(m \cdot \alpha(n))
    - $m$: 연산 개수
        
    - $\alpha(n)$: **역 아커만 함수**
        
- 현실적 입력 크기에서는 $\alpha(n) \leq 4$ → 사실상 **상수 시간**
    

---

## 5) 랭크(rank)의 의미

- **트리 높이의 상한선**을 추적하는 값
    
- 초기: `MAKE-SET` 시 rank = 0
    
- 두 트리를 합칠 때
    
    - rank가 다른 경우 → 낮은 쪽을 높은 쪽 밑에 붙이고 rank 그대로
        
    - rank가 같은 경우 → 한쪽을 루트로 하고 rank를 +1 증가
        

👉 루트의 rank는 실제 높이가 아니라 **균형을 위한 힌트**

---

## 6) 루트 선택 규칙

- 루트는 단순히 **집합의 대표자**일 뿐, 정렬이나 크기 기준 없음
    
- 같은 집합에 속하면 **항상 같은 루트**를 공유
    
- 루트 선택 기준은 **rank/size 최적화**뿐
    

---

## 7) 활용 사례

- **Kruskal MST 알고리즘**: 간선 추가 시 사이클 여부 검사
    
- **네트워크 연결성 판정**: 두 정점이 같은 컴포넌트에 있는지 확인
    
- **동적 집합 관리**:
    
    - 소셜 네트워크 친구 그룹
        
    - 동적 connectivity 문제
        

---

## 8) 의사코드 (자연어 요약)

1. **MAKE-SET(x)**
    
    - `parent[x] = x`, `rank[x] = 0`
        
2. **FIND-SET(x)**
    
    - x가 루트면 반환
        
    - 아니면 parent[x]를 따라 루트 탐색
        
    - 경로 압축: 지나온 노드를 루트에 직접 연결
        
3. **UNION(x, y)**
    
    - `rx = FIND(x)`, `ry = FIND(y)`
        
    - 루트가 같으면 그대로
        
    - 다르면 rank 비교 → 작은 쪽을 큰 쪽 밑에 붙임
        
    - rank가 같으면 한쪽을 루트로 하고 rank+1
        

---

## 9) 직관적 비유

- 여러 **친구 그룹**이 있다고 생각해보자
    
    - `FIND(x)` = “이 친구의 그룹장은 누구야?”
        
    - `UNION(x, y)` = “두 그룹장을 만나게 해서 그룹을 하나로 합쳐!”
        
- 그룹장이 바뀌면, 해당 그룹 전체가 새 그룹장 밑으로 들어가게 된다
    

---

## ✅ 최종 요약

- 유니온 파인드는 **서로소 집합**을 빠르게 합치고 조회하는 자료구조
    
- 핵심 최적화 = **Union by Rank + Path Compression**
    
- 시간 복잡도 = 사실상 **상수 시간**
    
- MST(Kruskal), 연결성 판정, 네트워크 문제 등에서 자주 활용