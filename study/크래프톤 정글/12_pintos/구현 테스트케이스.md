---
date: 2025-11-06
title: Pintos Threads — 이번주 구현 로드맵
updated: 2025-11-06
tags: [CS, donation, mlfqs, os, pintos, scheduler, threads]
---

# 🎯 이번주 목표 (코드 X, 설계/구현 체크리스트 O)

> [!summary] 범위
> 테스트 목록:  
> **Alarm(1–6)**, **Priority/Preemption(7, 14–17)**, **Priority Donation(8–13, 18)**, **MLFQS(19–26)**

---

## 0) 공통 기반 정리
- [ ] `ready_list`를 **우선순위 정렬 + 동순위 FIFO**로 운용
- [ ] `sema/lock/condvar`의 **대기열도 우선순위 정렬**
- [ ] 선점 트리거 지점에서 **즉시 재스케줄 판단**  
      (`thread_unblock`, `sema_up`, `lock_release`, `cond_signal/broadcast`, 타이머 인터럽트 등)
- [ ] `struct thread` 확장
  - [ ] `priority_base`(기본), `priority_effective`(기부 반영)
  - [ ] `waiting_lock` (내가 기다리는 락)
  - [ ] `held_locks` (보유 락 목록)
  - [ ] MLFQS용: `nice`, `recent_cpu`
- [ ] idle 스레드 처리 규칙 숙지(MLFQS 집계에서 **제외**)

---

## 1) Alarm 시계 (tests 1–6)
**핵심:** `timer_sleep(ticks)` → 현재 스레드를 **block**하고, `wake_tick`이 되면 **unblock**

- [ ] “슬립 대기 리스트”를 **wake_tick 오름차순**으로 관리
- [ ] 매 tick(`timer_interrupt`)마다 **리스트 선두만** 확인해 깨울 시각 도달 스레드 **전부** 깨움
- [ ] 깨움 즉시 **더 높은 우선순위 있으면 선점**
- [ ] 경계값: `ticks == 0` 또는 음수 → **즉시 반환**

> [!check] 통과 기준 매핑
> - `alarm-single/multiple/simultaneous` = 정확한 슬립/동시 깨움  
> - `alarm-priority` = 깨움 직후 우선순위 선점  
> - `alarm-zero/negative` = 경계값 처리

---

## 2) 우선순위 스케줄러 & 선점 (tests 7, 14–17)
**핵심:** 항상 **가장 높은 우선순위**가 실행. **동순위 FIFO**. 더 높은 우선순위가 준비되면 **즉시 선점**.

- [ ] `ready_list`를 우선순위 정렬 + **안정(FIFO)** 로 유지
- [ ] `thread_unblock()`에서 **현재 실행 중인 스레드와 우선순위 비교 → 필요 시 yield**
- [ ] `thread_set_priority(new)` (Donation 비활성 시): **즉시 재스케줄 판단**
- [ ] `sema_up/lock_release/cond_signal` 시 **가장 높은 대기자**를 깨움

> [!check] 통과 기준 매핑
> - `priority-fifo` = 동순위 FIFO 유지  
> - `priority-preempt` = 높은 우선순위가 등장하면 즉시 선점  
> - `priority-sema` / `priority-condvar` = 동기화 대기열 우선순위 기반  
> - `priority-change` = 런타임 우선순위 변경 시 즉시 양보

---

## 3) 우선순위 기부 (Priority Donation) (tests 8–13, 18)
**핵심:** **락 보유자에게 우선순위 기부**. **체인 전파** 가능. 락 **해제 시 원복**.

- [ ] `lock_acquire`  
  - [ ] 누군가 보유 중이면 **보유자에게 내 우선순위 기부**  
  - [ ] 보유자가 다른 락을 기다리는 경우 **체인으로 상위 보유자까지 전파**
- [ ] `lock_release`  
  - [ ] 해당 락을 통한 기부 제거  
  - [ ] 남아있는 `held_locks`의 기부 최댓값과 `priority_base`로 `priority_effective` **재계산**
- [ ] 모든 동기화 대기열 **우선순위 정렬** 유지

> [!check] 통과 기준 매핑
> - `donate-one` = 단일 기부  
> - `donate-multiple/multiple2` = 복수 기부 동시 처리  
> - `donate-nest/chain` = 깊은 체인 전파 정확성  
> - `donate-sema` = 세마포어 경로에서도 기부 반영  
> - `donate-lower` = 락 해제 후 **정확한 원복**  
> - `priority-donate-*` 전반 = 최대값 기반 재계산 로직 신뢰성

---

## 4) MLFQS (Multi-Level Feedback Queue Scheduler) (tests 19–26)
**전제:** **Donation 비활성**. 우선순위는 수식으로 **자동 산정**.

- [ ] 고정소수점(FP) 연산 유틸 정리(스케일 통일)
- [ ] 수식 구현 및 범위 클램프
  - [ ] `priority = PRI_MAX - recent_cpu/4 - nice*2` (클램프: `PRI_MIN..PRI_MAX`)
  - [ ] `recent_cpu = (2*load_avg)/(2*load_avg+1) * recent_cpu + nice`
  - [ ] `load_avg = (59/60)*load_avg + (1/60)*ready_threads`
    - [ ] `ready_threads = ready 큐 스레드 수 + (실행 중이면 +1)` (**idle 제외**)
- [ ] **업데이트 주기**
  - [ ] 매 tick: 실행 중 스레드 `recent_cpu += 1`
  - [ ] 매 **1초(100 ticks)**: **모든 스레드** `recent_cpu`, `load_avg` 재계산
  - [ ] 매 **4 ticks**: **모든 스레드** `priority` 재계산
- [ ] MLFQS가 켜진 동안 `thread_set_priority`는 **무시**, `set_nice`는 **우선순위 재산정 트리거**

> [!check] 통과 기준 매핑
> - `mlfqs-load-1/60/avg` = `load_avg`·`ready_threads` 집계 정확성  
> - `mlfqs-recent-1` = `recent_cpu` 갱신 타이밍  
> - `mlfqs-fair-2/20` = 공정한 CPU 분배  
> - `mlfqs-nice-2/10` = nice↑ → 우선순위↓ 반영

---

## 🧪 Definition of Done (DoD)
- [ ] **알람**: 동시 깨움·경계값·선점까지 정상
- [ ] **스케줄러**: 우선순위 최댓값 실행·동순위 FIFO·모든 트리거에서 선점
- [ ] **기부**: acquire에서 체인 전파, release에서 정확한 원복(남은 락 고려)
- [ ] **MLFQS**: 수식·주기·집계 규칙 정확, donation 비활성 모드 분기
- [ ] **테스트**: 해당 묶음 100% 통과

---

## 🧨 흔한 실패 패턴(셀프 점검)
- [ ] `thread_unblock` 이후 **즉시 선점** 누락 → `priority-preempt` 실패
- [ ] `cond_signal`이 **최고 우선순위 웨이터**를 안 깨움 → `priority-condvar` 실패
- [ ] `lock_release` 후 **기부 재계산 누락** → `donate-lower` 실패
- [ ] MLFQS **주기(1/4/100 tick)** 착각 → `mlfqs-*` 전반 실패
- [ ] `ready_threads` 계산에 **idle 포함** 또는 실행 중 스레드 미포함 → `load-*` 실패
- [ ] 고정소수점 연산 순서 오류/반올림 누락 → 공정성 테스트 흔들림

---

## 📎 참고 경로(로컬)
- 테스트 소스: `src/threads/tests/threads/`
- 결과 로그: `src/threads/build/tests/threads/*.result`

> [!tip] 디버깅 팁
> 실패 테스트 하나 골라 **대기열/ready_list**의 스냅샷(우선순위, 도착순서)을 로그로 찍어보면 원인 대부분 바로 잡힌다.

