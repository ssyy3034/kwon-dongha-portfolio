# StoLink & StoRead - 웹소설 작가를 위한 지식 관리 플랫폼

> 5인 팀 프로젝트 | **기획, 프론트엔드 70%, 백엔드 20%** | React + TypeScript + Spring Boot

웹소설 작가가 글을 쓰면 AI가 인물·관계·사건을 자동 분석하여 그래프로 시각화해주는 **창작 보조 플랫폼**입니다. 작가는 StoLink에서 에디터와 데이터 시각화를 통해 체계적으로 글을 쓰고, 배포한 글을 통해 StoRead에서 독자들이 관계도와 함께 작품을 열람하거나 구매할 수 있습니다.

---

## 1. 렌더링 성능 최적화: SVG → Canvas 전환

### 문제 상황

D3.js SVG 기반 소설 인물 관계도에서 노드 50개만 넘어도 클릭 및 드래그 응답이 **420ms**까지 느려지는 문제가 발생했습니다.

### 원인 분석

DevTools Performance 탭으로 분석한 결과, SVG 각 요소마다 발생하는 **Style Recalculation**이 병목임을 확인했습니다. SVG는 각 노드가 개별 DOM 요소로 존재하기 때문에, 노드 수가 증가할수록 브라우저의 스타일 재계산 비용이 기하급수적으로 증가하는 구조적 한계가 있었습니다.

### 해결 과정

SVG/DOM의 한계를 이해하고 **Canvas 렌더링**으로 전환했습니다.

- 수천 개의 DOM 요소를 **단일 Canvas 엘리먼트**로 통합하여 브라우저 렌더링 부하를 제거
- 캐릭터 이미지는 **Offscreen Canvas에 비트맵 캐싱**하고, 개별 노드를 단일 렌더 루프에서 일괄 렌더링
- Canvas에서는 DOM 이벤트를 사용할 수 없으므로, 좌표 기반 히트 테스트로 클릭/드래그 이벤트를 직접 구현

### 성과

- **650+ 노드에서도 60FPS 유지**
- **INP 420ms → 64ms로 개선**

---

## 2. 데이터 처리 최적화: 트리 변환 메모이제이션

### 문제 상황

폴더 구조가 깊어질수록 사이드바의 렌더링 속도가 느려졌습니다. 계층형 문서 구조(Flat Array → Nested Tree)를 매 렌더링마다 재귀적으로 변환하고 있어 **O(n²) 연산이 반복** 발생, 문서 100개 기준 15~20ms가 소요되었습니다.

### 해결 과정

기본 자료구조로 돌아가 구조를 재검토했습니다.

- **HashMap 기반 O(n) 트리 조립 로직**으로 리팩토링
- `useMemo`로 데이터 변경 시에만 재연산되도록 최적화
- React의 **참조 동등성**을 활용해 불필요한 재연산을 제거

폴더 트리 조회 시 발생하는 N+1 쿼리를 **Fetch Join**으로 해결하고, 조회된 데이터를 **In-Memory에서 트리 구조로 조립**하여 응답 성능을 최적화했습니다.

### 성과

- **O(n²) → O(n) 전환**: 문서 100개 기준 15~20ms → 1ms 이하로 개선
- **N+1 쿼리 → Fetch Join & In-Memory 조립**: API 응답 450ms → 25ms (18배 개선)

---

## 3. 번들 최적화

### 문제 상황

초기 로딩이 느리다는 피드백을 받았습니다. Lighthouse 분석 결과, Export 라이브러리(docx 714KB, jspdf 341KB)가 초기 번들에 포함되어 있었습니다.

### 해결 과정

- `vite.config.ts`의 **manualChunks** 설정으로 용도별 청크 분리
- 마우스 호버 시 **사전 로딩(Prefetch)** 적용하여 사용자가 실제로 해당 기능에 진입할 때는 이미 리소스가 준비되도록 구성

### 성과

- **초기 JS 번들 450KB → 187KB (58% 절감, gzip)**
- 라이브러리별 청크 분리로 캐시 효율 증대

---

## 4. 크레딧 결제 시스템 (백엔드)

### 문제 상황

StoRead에서 유료 작품 열람을 위한 크레딧 충전/차감 시스템이 필요했습니다. 토스페이먼츠 테스트 결제 API를 연동하여 실제 결제 흐름(승인 → 확인 → 웹훅)을 구성했습니다.

### 해결 과정

#### 트랜잭션 범위 분리

외부 PG API 응답이 느릴 경우 DB 트랜잭션이 길어져 커넥션 풀이 고갈되는 구조적 문제를 인지하고, **외부 호출을 트랜잭션 범위 밖으로 분리**했습니다.

#### 3중 방어 체계

결제 안정성을 위해 동시성 문제를 3가지 계층으로 나누어 해결했습니다.

| 방어 계층                         | 적용 대상      | 목적                                              |
| :-------------------------------- | :------------- | :------------------------------------------------ |
| **비관적 락** (PESSIMISTIC_WRITE) | 크레딧 잔액    | 경합이 잦은 잔액 차감에서 Race Condition 방지     |
| **낙관적 락** (@Version)          | 결제 상태 변경 | 결제 상태 전이(PENDING → COMPLETED)의 무결성 보장 |
| **멱등키** (Idempotency Key)      | 결제 요청      | 네트워크 재시도 등 순차적 중복 요청 방어          |

### 검증

**Testcontainers**로 운영 환경과 동일한 PostgreSQL 위에서 동시성 테스트를 작성했습니다.

- 100개 스레드 동시 차감 요청에서 **잔액 정합성 100% 보장**
- 잔액 부족 시 **초과 차감 완벽 방어** 확인

---

## 5. 팀 협업: Git 워크플로우 자동화

### 문제 상황

5인 팀에서 Git 숙련도 격차로 브랜치 충돌, 커밋 컨벤션 미준수, 이슈 트래킹 누락 등의 문제가 반복 발생했습니다.

### 해결 과정

**Antigravity**를 활용하여 이슈 생성 → 브랜치 생성 → 커밋 → PR 작성까지 **단일 명령으로 연결**하는 워크플로우를 구축했습니다.

### 성과

- 개인 도구로 시작했으나 **팀 전체가 사용**하게 되었고, 이후 다른 프로젝트 팀으로도 확산
- 개발 외적인 프로세스 고민을 덜어내어 팀원들이 핵심 로직 개발에 집중

---

## Tech Stack

| 영역              | 기술 스택                                                 |
| :---------------- | :-------------------------------------------------------- |
| **Core**          | React 19, TypeScript 5.7, Vite                            |
| **State**         | Zustand (Client State), TanStack Query (Server State)     |
| **Visualization** | HTML5 Canvas, D3.js, react-force-graph-2d                 |
| **Editor**        | Tiptap (ProseMirror 기반)                                 |
| **Backend**       | Spring Boot, JPA, PostgreSQL, Neo4j                       |
| **Infra**         | Docker Compose, AWS (EC2, S3, CloudFront), GitHub Actions |
| **Tools**         | Claude Code CLI, Antigravity                              |
