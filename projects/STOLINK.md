# StoLink - 프론트엔드 기술 챌린지 및 회고

> 5인 팀 프로젝트 | **프론트엔드 리드** | React + TypeScript + D3.js

작가용 웹 에디터 및 캐릭터 관계도 시각화 서비스의 프론트엔드 아키텍처를 설계하고, **사용자 경험(UX)과 성능 최적화**에 집중하여 개발했습니다.

---

## 1. 렌더링 엔진 마이그레이션: 사용자 경험을 위한 집요한 개선

### 문제 상황

D3.js 기반의 캐릭터 관계도에서 노드가 **30개를 넘어가자 프레임 드랍(60fps → 10fps 미만)**이 발생했습니다. 줌/팬 조작 시 버벅이는 현상 때문에 "몰입이 깨진다"는 피드백을 받았습니다.

### 원인 및 해결 과정

Chrome Performance Profiler로 분석한 결과, **SVG(DOM) 요소가 너무 많아 Style Recalculation 비용이 높다는 것**을 발견했습니다. 이를 해결하기 위해 **HTML5 Canvas**로 렌더링 방식을 완전히 전환했습니다.
이를 통해 수천 개의 DOM 요소를 단일 Canvas 엘리먼트로 통합하여 브라우저 렌더링 부하를 제거했으며, 빈번히 그려지는 노드 이미지는 **메모리 캐싱(Texture Caching)** 기법을 적용하여 드로잉 성능을 극대화했습니다.

### 배운 점 및 성과

- **Stable 60fps 달성**: 600개 이상의 노드에서도 끊김 없는 조작감을 제공했습니다.
- **최적화의 본질**: "기술 교체"보다 중요한 것은 "병목 지점(DOM Overhead)의 정확한 진단"임을 배웠습니다.

---

## 2. 문서 트리 최적화: 기본 자료구조의 응용

### 문제 상황

폴더 구조가 깊어질수록 사이드바의 렌더링 속도가 느려졌습니다. 분석 결과, 트리를 그릴 때마다 재귀적으로 데이터를 탐색하는 로직(`O(n^2)`)이 매번 실행되고 있었습니다.

### 해결 과정

기본으로 돌아가 자료구조를 재검토했습니다. 전체 데이터를 `HashMap` 형태의 평탄화된 배열로 관리하고, 렌더링 시에만 필요한 부분(Open된 폴더)을 **O(n) 선형 탐색**으로 가져오도록 구조를 변경했습니다. 여기에 `useMemo`를 적용하여 데이터 변경이 없을 때는 연산 자체를 건너뛰도록 했습니다.

### 배운 점 및 성과

- **연산 속도 150배 단축**: 인터랙션 딜레이를 15ms에서 0.1ms 수준으로 줄였습니다.
- **기본의 중요성**: 복잡한 라이브러리보다 때로는 기본적인 자료구조 설계가 성능에 더 큰 영향을 준다는 것을 깨달았습니다.

---

## 3. 팀을 위한 자동화: Smart-Commit 워크플로우

### 문제 상황

팀원마다 Git 숙련도가 달라 충돌(Generic Merge Conflict)이 잦았고, 이슈와 커밋이 연결되지 않아 히스토리를 파악하기 어려웠습니다.

### 해결 과정

반복되는 "이슈 생성 - 브랜치 생성 - 커밋 메시지 작성 - PR 생성" 과정을 하나의 흐름으로 자동화하고 싶었습니다. 이를 위해 **Smart-Commit**이라는 CLI 도구를 만들어 팀에 도입했습니다.

- **자동 연결**: 브랜치 이름에서 이슈 번호를 추출하여 커밋 메시지에 자동으로 추가합니다.
- **품질 확보**: 커밋 전 자동으로 Lint와 Build 체크를 수행하여, 실수로 깨진 코드가 올라가는 것을 방지했습니다.

### 배운 점 및 성과

- **협업 비용 감소**: 개발 외적인 프로세스 고민을 덜어내어 팀원들이 핵심 로직 개발에 집중할 수 있었습니다.
- **문서화 동기화**: 코드가 변하면 문서도 함께 업데이트되는 `Sync-Docs` 문화를 정착시켰습니다.

---

## 4. AI 오케스트레이션 아키텍처: Supervisor System

### 문제 상황

"AI를 개발에 도입하자"는 목표는 좋았지만, 맥락 없이 질문하면 환각(Hallucination)이 발생하고, 모든 파일을 context로 넣으면 토큰 비용이 감당되지 않았습니다.

### 해결 과정: 시스템으로서의 AI 설계

단순한 챗봇이 아닌, **역할 기반 에이전트 시스템(Role-Based Agent System)**을 구축했습니다.

1.  **Supervisor (지휘자)**: 사용자 요청의 크기(S/M/L)를 분석하여 작업 전략을 수립합니다.
2.  **Dynamic Context Injection**: 작업에 필요한 문서(디자인 시스템 vs 아키텍처 문서)만 선별하여 프롬프트에 동적으로 주입하는 **T-shirt Sizing 전략**을 구현했습니다.
3.  **Quality Gate**: Auditor 에이전트가 코드를 검수하지 않으면 커밋조차 불가능하도록 파이프라인을 강제했습니다.

### 성과

- **환각 최소화**: 필요한 맥락만 제공하여 AI의 정확도를 비약적으로 높였습니다.
- **비용 최적화**: 무분별한 토큰 사용을 막고 효율적인 엔지니어링 파이프라인을 정착시켰습니다.

---

## 5. 번들 사이즈 최적화와 사용자 배려

### 문제 상황

초기 로딩 시 사용하지도 않는 무거운 라이브러리(D3, Tiptap 등)까지 모두 다운로드받느라 TTI(Time To Interactive)가 늦어지는 문제가 있었습니다.

### 해결 과정

`vite.config.ts`의 `manualChunks` 설정을 세밀하게 조정하여, 사용자가 실제로 해당 페이지(에디터, 관계도 등)에 진입할 때만 리소스를 로드하도록 **지연 로딩(Lazy Loading)**을 적용했습니다.

### 성과

- **초기 번들 사이즈 30% 감소**: 필요한 것만 빠르게 보여주는 것이 사용자에 대한 배려임을 배웠습니다.
- **캐시 효율 증대**: 라이브러리별로 청크를 나누어, 코드가 조금만 바뀌어도 전체를 다시 받는 비효율을 개선했습니다.

---

## 5. Tech Stack & Environment

| 영역              | 기술 스택                                             |
| :---------------- | :---------------------------------------------------- |
| **Core**          | React 19, TypeScript 5.7, Vite                        |
| **State**         | Zustand (Client State), TanStack Query (Server State) |
| **Visualization** | HTML5 Canvas, D3.js, react-force-graph-2d             |
| **Editor**        | Tiptap (ProseMirror 기반 Custom Extension 개발)       |
| **DevOps**        | GitHub Actions, Docker, Smart-Commit Workflow         |

---

> **"기술은 결국 문제를 해결하기 위한 도구"**라는 마음으로, 화려한 기술보다는 실제 사용자와 팀에게 필요한 경험을 만드는 데 집중했습니다.
