---
date: 2025-12-10
tags: [CS]
---

# 프로젝트 1: 스레드 (Threads) 리캡

이 문서는 카이스트 Pintos 프로젝트 1: Threads의 구현 과정을 **Before (기존 문제점)** 와 **After (개선된 구현)** 형식으로 비교하여 정리합니다.

---

## 1. 알람 시계 (Alarm Clock)

### 🔴 Before: 바쁜 대기 (Busy Waiting)

- **구현 방식**: 
    
    timer_sleep() 함수가 호출되면, 스레드는 `while` 루프 내에서 
    
    thread_yield()를 반복적으로 호출하며 시간이 지났는지 계속 확인합니다.
- **문제점**: 대기 중인 스레드가 CPU를 계속 점유하여 소모하므로, 실제로 작업을 수행해야 하는 다른 스레드들의 실행 기회를 뺏고 전력과 자원을 낭비합니다.

/* 기존 busy wait 방식 */

void timer_sleep(int64_t ticks) {

    int64_t start = timer_ticks();

    while (timer_elapsed(start) < ticks)

        thread_yield();

}

### 🟢 After: 슬립 리스트 (Sleep/Wakeup Mechanism)

- **개선 방식**: 스레드를 재울 때 대기 상태(Blocked)로 만들고, 깨어날 시간에 맞춰 운영체제가 깨워주는 방식으로 변경했습니다.
- **구현 내용**:
    1. **`sleep_list` 도입**: 대기 중인 스레드를 관리하는 리스트를 
        
        devices/timer.c에 추가했습니다.
    2. **`struct thread` 확장**: 스레드가 깨어날 시간인 
        
        wakeup_tick 필드를 추가했습니다.
    3. **대기 로직 수정**: 
        
        timer_sleep()에서 스레드를 `sleep_list`에 삽입(오름차순 정렬)하고 
        
        thread_block()을 호출하여 CPU 사용을 중단합니다.
    4. **깨움 로직 추가**: 매 틱마다 발생하는 
        
        timer_interrupt()에서 `sleep_list`를 검사하여, 현재 시간이 
        
        wakeup_tick에 도달한 스레드들을 
        
        thread_unblock()으로 깨웁니다.
- **효과**: 불필요한 CPU 낭비를 제거하여 시스템 효율성을 높였습니다.

---

## 2. 우선순위 스케줄링 (Priority Scheduling)

### 🔴 Before: 라운드 로빈 (Round Robin) & 우선순위 역전

- **구현 방식**: 준비 큐(`ready_list`)에 들어온 순서대로 스레드를 실행하는 라운드 로빈 방식을 사용했습니다. 또한, 락(Lock)을 기다릴 때 우선순위를 고려하지 않았습니다.
- **문제점**:
    1. **우선순위 무시**: 높은 우선순위의 스레드가 낮은 우선순위 스레드 뒤에서 기다려야 했습니다.
    2. **우선순위 역전 (Priority Inversion)**: 높은 우선순위 스레드(H)가 낮은 우선순위 스레드(L)가 잡고 있는 락을 기다릴 때, 중간 우선순위 스레드(M)가 L을 선점해버리면 H가 예상보다 훨씬 오래 기다리게 되는 현상이 발생합니다.

### 🟢 After: 엄격한 우선순위 스케줄링 & 우선순위 기부

- **개선 방식**: 항상 가장 높은 우선순위 스레드를 실행하도록 보장하고, 락 대기 시 우선순위 기부를 통해 역전 현상을 해결했습니다.
- **구현 내용**:
    1. **정렬된 준비 큐**: `ready_list`에 스레드를 넣을 때(
        
        thread_unblock, 
        
        thread_yield) 항상 우선순위 내림차순으로 정렬되도록 `list_insert_ordered()`를 사용했습니다.
    2. **선점 구현**: 새로운 스레드가 생성되거나 깨어날 때, 현재 실행 중인 스레드보다 우선순위가 높으면 즉시 문맥 교환(Context Switch)이 일어나도록 
        
        preempt_priority()를 구현했습니다.
    3. **우선순위 기부 (Priority Donation)**:
        - lock_acquire() 시, 락을 이미 누군가 잡고 있다면 그 스레드(Holder)에게 자신의 높은 우선순위를 빌려줍니다(기부).
        - **중첩 기부 (Nested Donation)** 구현: H -> M -> L 형태로 락을 기다릴 때, H의 우선순위가 L까지 전달되도록 구현했습니다.
        - **다중 기부 (Multiple Donation)** 고려: 한 스레드가 여러 락을 잡고 있을 때, 각 락을 기다리는 가장 높은 우선순위들 중 최댓값을 갖도록 했습니다.
        - lock_release() 시, 기부받은 우선순위를 원래대로 되돌리고(복구), 아직 다른 락을 잡고 있다면 남은 기부값들로 우선순위를 재조정합니다.
    4. **조건 변수 & 세마포어**: 
        
        cond_wait, 
        
        sema_down 등 대기열도 우선순위 순서로 관리하여 높은 우선순위 스레드가 먼저 신호를 받도록 했습니다.
- **효과**: 중요한 작업(높은 우선순위)이 지연 없이 빠르게 처리됨을 보장합니다.

---

## 3. 고급 스케줄러 (MLFQS)

### 🔴 Before: 단순 우선순위 스케줄링의 한계

- **구현 방식**: 사용자가 지정한 고정 우선순위만 사용했습니다.
- **문제점**: **기아 현상 (Starvation)**. 우선순위가 낮은 스레드는 높은 우선순위 스레드가 계속 존재하는 한 영원히 CPU를 할당받지 못할 수 있습니다.

### 🟢 After: Multi-Level Feedback Queue Scheduler (MLFQS)

- **개선 방식**: 4.4BSD 스케줄러를 본따, 최근 CPU 사용량과 시스템 부하(Load Average)를 기반으로 우선순위를 동적으로 조정합니다.
- **구현 내용**:
    1. **고정 소수점 연산 (Fixed-Point Arithmetic)**: 커널 내에서 부동 소수점 연산을 흉내 내기 위해 정수 연산을 이용한 고정 소수점 라이브러리(매크로)를 구현했습니다 (17.14 포맷).
    2. **새로운 지표 도입**:
        - recent_cpu: 스레드가 최근에 얼마나 CPU를 썼는지 나타내는 값 (지수 가중 이동 평균).
        - load_avg: 현재 시스템에서 실행 대기 중인 스레드의 평균 수.
        - nice: 스레드가 다른 스레드에게 양보하려는 정도 (-20 ~ 20).
    3. **동적 우선순위 계산**:
        - 매 4틱마다 모든 스레드의 우선순위를 재계산합니다.
        - 공식: `priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)`
        - CPU를 많이 쓴 스레드는 우선순위가 낮아지고, 오래 기다린 스레드는 우선순위가 높아집니다.
    4. **주기적 업데이트**: 
        
        timer_interrupt에서 매 틱마다 실행 중인 스레드의 
        
        recent_cpu를 1 증가시키고, 1초마다 모든 스레드의 
        
        recent_cpu와 
        
        load_avg를 갱신(decay)합니다.
- **효과**: 모든 스레드가 공평하게 CPU를 할당받으며(Fairness), 입출력(I/O) 위주의 작업은 반응성을 높이고, CPU 위주의 작업은 우선순위를 낮춰 전체 시스템의 균형을 맞춥니다.