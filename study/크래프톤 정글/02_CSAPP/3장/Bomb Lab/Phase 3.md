---
date: 2025-09-29
tags: [Retrospective]
---


# Bomb Lab – Phase 3 정리

## Prologue

Phase 3는 본격적으로 **어셈블리 레벨의 분기 구조**를 이해해야 하는 구간이다.  
처음에는 단순히 `switch` 문을 뜯어보는 것 같았지만, 실제로는 **점프 테이블이 메모리에서 어떻게 동작하는지**를 직접 추적해야 한다는 점이 흥미로웠다.

---

## 핵심: Switch 문과 점프 테이블

C에서 `switch` 문은 조건 분기지만, 어셈블리에서는 **점프 테이블(Jump Table)** 형태로 최적화된다.

비유하면, 아파트 우편함 같다:

- 첫 번째 입력값 = 우편함 번호
    
- 점프 테이블 = 우편함에 적힌 주소 모음
    
- 점프 = 우편함 열어서 해당 집으로 가기
    
- 없는 번호 = 경비실 → 폭탄
    

이 구조를 이해하면 Phase 3는 크게 어렵지 않다.

---

## 공략 단계

### 1. 입력값 형식 확인

- `disas phase_3` → `sscanf@plt` 확인
    
- 포맷 스트링을 따라 몇 개의 입력값을 어떤 타입으로 받는지 체크
    

### 2. 입력값 범위 찾기

```assembly
cmpl   $0x7,%eax
ja     bomb
```

- 유효 범위는 0 ~ 7
    

### 3. 점프 테이블 확인

```assembly
jmp *0x4024d0(,%rax,8)
```

- `0x4024d0` → 점프 테이블 시작 주소
    
- `x/8gx 0x4024d0` → 각 케이스별 점프 위치 확인
    

### 4. Case별 조건 분석

- 각 점프 주소로 들어가서 코드 확인
    
- 보통 두 번째 입력값 검사
    
- 조건을 만족하는 `(첫 번째 입력값, 두 번째 입력값)` 쌍이 정답
    

---

## 배운 점

- 단순히 C 코드를 아는 것과, 그것이 **어셈블리로 변환되어 실행되는 흐름**을 아는 건 완전히 다른 차원이라는 걸 느꼈다.
    
- 특히 점프 테이블을 메모리 주소 단위로 까보니, 추상적으로만 알던 `switch` 최적화가 잘 이해되었다.
    
- GDB에서 `x/8gx` 같은 명령으로 메모리 덤프를 직접 확인하는 과정이 큰 도움이 됐다.
    

---

## 회고

Phase 3는 분기 구조의 본질을 건드린다.  
앞으로 코드를 작성할 때도, “이게 어셈블리에서는 어떻게 풀릴까?”라는 관점을 놓치지 않으려 한다. 결국 디버깅도, 성능 최적화도 이런 눈높이에서 출발한다고 믿는다.
