---
date: 2025-11-13
tags: [CS]
---


# 1. Pintos Userprog에서 핵심이 되는 레지스터 개념

Pintos user program 실행 흐름에서 가장 중요한 레지스터는 다음 네 범주이다.

---

## 1) **EIP / RIP** (Instruction Pointer)

- 현재 실행 중인 **명령어의 주소**를 보관
    
- 유저 프로그램의 entry point(ELF에 기록된 주소)로 설정됨
    
- `intr_exit()`이 유저 모드로 복귀할 때,
    **intr_frame.eip** → EIP로 로드됨
    

Pintos userprog에서 EIP는 **프로세스 시작의 핵심**이다.

---

## 2) **ESP / RSP** (Stack Pointer)

- 현재 **스택의 최상단 주소**를 가리킴
    
- 유저 프로그램 시작 시:
    
    - `setup_stack()`에서 유저 스택을 구성
        
    - intr_frame.esp에 해당 스택 주소 저장
        
- 시스템 콜 호출 시 유저 스택 주소에서 인자 읽기
    

핵심: **유저 스택의 값은 전부 유저 메모리에 있어야 하며, 유효성 검증 필요**.

---

## 3) **EAX / RAX** (Return Register)

- 시스템 콜 **리턴값을 저장**하는 레지스터
    
- Pintos에서는:
    
    - 사용자 코드가 `int 0x30` 호출 시 **EAX = syscall 번호**
        
    - 커널이 처리 후 **f->eax**에 결과 저장 → 유저로 복귀 시 RAX에 기록됨
        

즉, EAX는 Pintos syscall 인터페이스의 핵심.

---

## 4) **Segments (CS, DS, SS)**

Pintos는 x86 segmentation을 거의 사용하지 않지만, **유저/커널 모드 구분**에는 필요하다.

- `CS`의 DPL=3 → 유저 모드
    
- `CS`의 DPL=0 → 커널 모드
    
- `intr_exit()`이 유저로 복귀할 때
    
    - CS=SEL_UCSEG
        
    - SS=SEL_UDSEG
        

Pintos는 세그먼트를 최소한으로만 설정하며, **메모리 보호는 paging 기반**이다.

---

## 5) **CR2, CR3 (커널에서 사용)**

### CR2

- 페이지 폴트가 일어난 **faulting address** 저장
    
- userprog에서 page fault 처리 시 반드시 사용됨
    

### CR3

- 현재 **페이지 디렉토리의 물리 주소**를 가리킴
    
- 프로세스 context switch 시 CR3 = 프로세스의 pagedir
    

유저는 CR2/CR3에 접근할 수 없고 커널만 다룬다.

---

# 2. Pintos Userprog에서 핵심이 되는 메모리 개념

---

# 1) **유저 가상 주소 공간(User Virtual Address Space)**

Pintos userprog에서 유저 프로세스는 다음 구조를 가진다:

```
0x08048000 ~ ...       → 코드/데이터/힙(ELF 로드)
유저 스택 (최상위 아래)
----------------------------------
커널 영역 (유저 접근 불가, U=0)
----------------------------------
물리 메모리
```

구성 요소:

- ELF 로딩 시 `pagedir_set_page()`로 매핑
    
- 커널 영역은 U=0로 설정 → 유저 접근 시 **page fault**
    

---

# 2) **pagedir (페이지 디렉토리)**

Pintos는 페이징을 사용하여 유저/커널 메모리 보호를 수행한다.

유저 프로그램이 실행될 때:

1. `process_execute()`에서 새 pagedir 생성
    
2. ELF segment 로드 시 유저 페이지 매핑
    
3. `pagedir_activate()`로 CR3에 설정
    
4. context switch 될 때마다 각 프로세스의 pagedir을 CR3로 로드
    

핵심:  
**유저는 자기 pagedir 안의 U=1 페이지에만 접근 가능.**

---

# 3) **유저 스택(User Stack)**

`setup_stack()`에서 유저 모드 전용 스택을 생성.

과정:

1. 유저 스택용 페이지 하나를 VA 최상단에 매핑
    
2. 초기 esp를 페이지 끝(4KB 끝)으로 설정
    
3. argv/argc/문자열 배치
    

이 값은 intr_frame.esp에 들어가  
→ `intr_exit()` → 유저 RSP/ESP로 복구.

---

# 4) **커널 스택(Kernel Stack)**

Pintos에서는 각 스레드마다 **커널 스택이 존재한다.**

- 인터럽트/시스템 콜 발생 → CPU가 **커널 스택으로 자동 교체**
    
- 유저 모드 스택은 절대 커널 모드에서 사용하지 않음
    

따라서:

- **유저 스택은 프로세스용**
    
- **커널 스택은 커널 핸들러, 스케줄러용**
    

구조적으로 완전히 분리되어 있다.

---

# 5) **유저 메모리 접근 검증 (User Memory Validation)**

Pintos userprog에서 가장 중요한 메모리 개념.

유저 주소 접근 시 반드시 다음을 체크해야 한다:

1. 주소가 **유저 영역인지**
    
    ```c
    is_user_vaddr (uaddr)
    ```
    
2. 페이지가 **pagedir에서 매핑되었는지**
    
    ```c
    pagedir_get_page (pagedir, uaddr)
    ```
    
3. 문자열일 경우 끝까지 유효한지
    

검증 실패 →  
**exit(-1)**  
(리눅스처럼 SIGSEGV가 아니라 즉시 종료)

---

# 3. 명령어 수행 관점에서 본 userprog 레지스터 동작

Pintos에서 시스템 콜 호출 흐름 요약:

### 유저 코드

```
eax = SYS_WRITE
int $0x30
```

### 커널

- `interrupt.c` → 0x30 vector handler → `syscall_handler()`
    
- `syscall_handler(struct intr_frame *f)`에서:
    
    - f->eax = syscall 번호
        
    - 인자: 유저 esp(RSP)에서 직접 읽음
        

### 유저로 복귀

- 커널이 f->eax에 결과 저장
    
- `intr_exit()`에서 레지스터 복구
    
- RAX=리턴값으로 유저 코드 재개
    

---

# 4. Pintos 실행에서 레지스터/메모리 상호작용 핵심 요약

|개념|역할|
|---|---|
|**RIP/EIP**|유저 프로그램의 실행 위치|
|**RSP/ESP**|유저 스택, 시스템 콜 인자 전달 원천|
|**EAX**|syscall 번호 및 리턴값|
|**CR3**|프로세스 주소 공간 선택|
|**CR2**|페이지 폴트 주소 추적|
|**pagedir**|유저 주소 공간 구성, 보호|
|**U/S 비트**|유저 모드 접근 가능 여부|
|**유저 스택**|argv/argc, syscall 인자 저장|
|**커널 스택**|exception + syscall 처리용|

---

# 최종 핵심 정리 (userprog에 필요한 부분만)

1. **EIP/RIP**  
    → 유저 프로그램 entry 및 실행 위치
    
2. **ESP/RSP**  
    → 스택 기반 인자 전달, 시스템 콜 처리의 핵심
    
3. **EAX**  
    → 시스템 콜 번호 + 리턴값 전달
    
4. **CR3**  
    → 프로세스별 페이지 디렉토리 선택 (address space switching)
    
5. **CR2**  
    → page fault의 faulting address 파악
    
6. **유저/커널 메모리 보호**  
    → 페이징의 U/S 비트 기반
    
7. **유저 스택 구성**  
    → argv, 인자 정렬, 초기 스택 설정
    
8. **커널 스택 별도 존재**  
    → 시스템 콜/예외 처리의 안전성 확보
    
[[자세히]] 
