---
date: 2025-11-13
tags: [CS]
---


# 1. **인터럽트 프레임(intr_frame)의 하드웨어적 의미**

Pintos에서 시스템 콜·예외 처리는 `struct intr_frame`을 사용한다.

이 구조체는 단순 저장용이 아니라,  
**x86의 IRET 프레임(하드웨어 CPU 상태 저장 포맷)을 그대로 반영**한다.

핵심 필드:

|intr_frame 필드|CPU 레지스터 매핑|
|---|---|
|eip|RIP/EIP|
|esp|RSP/ESP|
|eflags|RFLAGS|
|cs/ss|세그먼트 셀렉터 (CPL 포함)|
|eax, ebx …|일반 목적 레지스터|

`intr_exit()`은 이 구조체를 그대로 CPU 상태로 “restore”하며  
**IRET을 실행함**.

즉, 이 구조체의 정확한 값이:

- 시스템 콜 리턴 주소
    
- 유저 스택
    
- 권한 레벨(CPL)
    
- EIP 복원  
    을 모두 결정한다.
    

→ 이 구조를 잘못 구성하면 userprog는 절대 정상 실행되지 않는다.

---

# 2. **IDT 게이트 디스크립터의 DPL이 시스템 콜 권한을 제어한다**

Pintos에서 시스템 콜은 **int 0x30**으로 들어온다.

IDT 엔트리에 설정하는 필드 중:

- **Type = Interrupt Gate / Trap Gate**
    
- **DPL = 3**  
    → 유저 모드에서 이 벡터 호출 가능
    

만약 DPL이 0이면:

- 유저가 `int $0x30` 실행 → **#GP fault**
    

즉, Pintos userprog에서 시스템 콜은 IDT의 **Gate Descriptor의 DPL=3** 설정 덕분에 가능한 것.

이 개념을 모르면 “왜 int 0x30이 user-mode에서 되지?”가 이해되지 않는다.

---

# 3. **CS 세그먼트 셀렉터의 DPL이 CPL을 결정한다**

CPL(Current Privilege Level)은 CPU 레지스터가 아니라  
**CS 디스크립터의 DPL 비트**에서 자동 결정된다.

즉:

- 유저→커널 전환: 하드웨어가 CS를 커널 세그먼트로 강제 변경
    
- 커널→유저 전환: intr_frame.cs = SEL_UCSEG(CPL=3)
    

`iret` 명령은 intr_frame.cs를 로드하고 CPL을 변경한다.

Pintos userprog 실행의 핵심:

```
intr_frame.cs = USER_CODE_SEG   (DPL=3)
intr_frame.ss = USER_DATA_SEG   (DPL=3)
intr_frame.eip = entry_point
intr_frame.esp = user_stack_top
```

→ 이것을 `intr_exit()`이 복원 → 즉시 유저 모드 진입.

---

# 4. **U/S 비트(User/Supervisor bit)의 유저/커널 메모리 보호**

페이징 기반 보호의 핵심은 PTE(Page Table Entry)의 U/S bit.

- **U=1**: 유저 모드 접근 가능
    
- **U=0**: 커널 전용 (유저 접근 시 즉시 page fault)
    

Pintos userprog 레벨에서 중요한 점:

### 모든 커널 주소는 U=0

### 모든 유저 영역은 U=1

이 비트를 잘못 설정하면:

- 유저 접근 → 즉시 페이지 폴트 → exit(-1)
    
- 또는 유저가 커널 영역을 읽어버리는 치명적 보안 문제 발생
    

---

# 5. **page fault error code의 비트 의미를 정확히 해석할 수 있어야 함**

Pintos에서는 page fault가 user fault인지, 커널 fault인지 판단해야 한다.

x86 page-fault error code 비트:

|비트|의미|
|---|---|
|0|P (Present) — 0이면 not-present, 1이면 protection fault|
|1|W/R (Write?)|
|2|U/S (User/Supervisor) — 1이면 유저 모드에서 fault|
|3|Reserved bit violation|
|4|Instruction fetch fault (if NX or protected)|

Pintos는 이 값을 보고:

- user mode fault → 해당 프로세스 즉시 종료
    
- kernel mode fault → Panic
    

따라서 **error_code & PF_U** 검사만으로 user fault 판별 가능.

---

# 6. **유저 스택 초기 구성의 정확한 규칙(alignment 포함)**

Pintos userprog에서 초기 유저 스택은 다음 규칙을 반드시 따라야 한다:

1. 스택은 **최상위 VA(4KB 페이지 끝)**에 위치
    
2. 문자열을 먼저 push
    
3. 각 문자열의 주소를 push
    
4. argv[]를 push
    
5. argc push
    
6. fake return address push
    
7. **스택 포인터는 4-byte aligned**
    

이 규칙이 깨지면:

- 실행 초기에 segmentation fault/page fault
    
- argv 해석 실패
    
- main() 진입 불가
    

alignment는 실수하기 쉽지만 매우 중요한 low-level 요소다.

---

# 7. **시스템 콜 인자 파싱은 유저 스택(유저 가상 주소)에서 바로 수행된다**

유저 스택에서 syscall 인자를 읽을 때:

- 유효 주소인지 검사
    
- 페이징된 주소인지 검사
    
- 문자열일 경우 끝까지 연속적으로 접근 가능한지 검사
    

즉, 커널은 유저 스택을 직접 dereference하지 않는다.  
반드시 검증하고 페이지 테이블을 통해 변환해야 한다.

---

# 8. **CR3 레지스터가 프로세스 간 주소 공간을 완전히 결정한다**

프로세스 전환 시 CR3를 바꾸는 것은 “페이지 디렉토리 교체”이다.

Pintos에서는:

```
pagedir_activate(pagedir);
```

이 함수가 CR3를 해당 프로세스의 pagedir로 설정한다.

즉:

- CR3 변경 = 주소 공간 변경
    
- 페이지 테이블 전체 교체 = 프로세스 격리 구현
    

Linux처럼 ASID가 없기 때문에  
**Pintos는 CR3 교체 시 TLB flush가 강제로 발생**한다.

---

# 9. **유저 스택 → 커널 스택 자동 전환(TSS) 메커니즘**

유저 모드에서 인터럽트·예외 발생 시:

1. 하드웨어가 TSS에 저장된 kernel stack pointer를 읽고
    
2. **커널 스택을 자동으로 활성화**
    
3. 유저 스택은 무시됨
    

즉, 커널은 유저 스택을 절대로 사용하지 않는다.  
이 구조 덕분에 userfault는 커널에 피해를 줄 수 없다.

---

# 10. **문맥 스위칭 시 레지스터 저장은 커널 스택 상단에서 이루어진다**

Pintos에서 스레드 전환 시:

- 커널 스택에 레지스터 상태 저장
    
- 다음 스레드의 커널 스택으로 스위칭
    
- 거기 저장되어 있던 레지스터 집합을 restore
    

중요:

- user → kernel 진입 시 user 레지스터는 intr_frame 구조체로 저장
    
- 커널 수준 문맥 스위치는 **커널 스택 내 구조체**를 사용
    

이 둘은 동일한 구조가 아니다.

---

# **정리: Pintos userprog 구현에서 필수적인 deep-level 개념**

1. intr_frame = IRET 프레임
    
2. IDT Gate Descriptor의 DPL=3이 syscall 가능 조건
    
3. CPL은 CS.DPL로 결정
    
4. 페이징의 U/S 비트가 유저/커널 보호의 핵심
    
5. page fault error code로 fault 원인 판별
    
6. 유저 스택 초기 구성 규칙(alignment 포함)
    
7. 시스템 콜 인자는 유저 스택에서 직접 읽되 매번 검증 필요
    
8. CR3 교체가 주소 공간 전환
    
9. 인터럽트 발생 시 커널 스택 자동 활성화
    
10. 문맥 스위칭은 user-frame과 kernel-context 두 단계로 관리됨
    

---

레지스터
|레지스터|역할|Pintos userprog에서의 의미|
|---|---|---|
|**EAX**|연산용/리턴값|syscall 번호 입력, syscall 결과 저장(f->eax)|
|**EBX**|연산용|인자 전달/임시 값|
|**ECX**|연산용|인자 전달/문자열 접근 시 사용|
|**EDX**|연산용|인자 전달|
|**ESI**|Source Index|memcpy, 문자열 복사에 사용될 수 있음|
|**EDI**|Destination Index|같은 용도|
|**EBP**|Base Pointer|함수 프레임 베이스|
|**ESP**|Stack Pointer|유저 스택 위치, syscall 인자 위치, main 진입 구조|